# 处理边界情况

这里都是和处理边界情况有关的功能，即一些需要对 Vue 的规则做一些小调整的特殊情况。

## 访问元素和组件

绝大多数情况下我们最好不要触达另一个组件实例内部或手动操作 DOM 元素，不过确实也有一些情况下做这些事情是合适的。

### 访问根实例

每个`new Vue`实例的子组件中，其根实例都可以通过`$root`属性进行访问。所有子组件都可以将这个实例作为一个全局 store 访问或使用。

对于 demo 或非常小型的有少量组件的应用来说是很方便的，不过这个模式扩展到中大型就不好了。因此在绝大多数情况下推荐使用 Vuex 管理应用的状态。

### 访问父组件实例

和`$root`类似，`$parent`属性可以用来从一个子组件访问父组件的实例。它提供了一种机会，可以在后期随时触达父级组件，以替代将数据以 prop 方式传入子组件的方式。

> 绝大多数情况下，触达父组件会使得你的应用更难调试和理解。尤其是你变更了父级组件数据的时候。当我们稍后会看那个组件的时候，很难找出那个变更是从哪里发起的。

另外在一些适当的时候，你需要特别地共享一些组件库。

### 访问子组件实例或子元素

尽管存在 prop 和事件，有的时候你仍然可能需要在 JavaScript 直接访问一个子组件。为了达到这个目的，你可以通过`ref`特性为这个子组件赋予一个 ID 引用。例如：`<base-input ref="usernameInput"></base-input>`，现在你已经定义了这个`ref`组件里，你可以使用：`this.$refs.usernameInput`来访问这个`<base-input>`实例。以便不时之需。比如程序化地从一个父级组件聚焦到这个输入框。当`ref`和`v-for`一起使用的时候，你得到的引用将会是一个包含了对应数据源的这些子组件的数组。

`$refs`只会在组件渲染完成之后生效，并且它们不是响应式的，这仅仅作为一个用于直接操作子组件的“逃生舱”——你应该避免在模板或计算属性中访问`$refs`。

### 依赖注入

使用`$parent`不能很好扩展到更深层级的嵌套组件上，这也是依赖注入的用武之地。它用到了两个新的实例选项：`provide`和`inject`

`provide`选项允许指定我们想要**提供**给后代组件的数据或方法。如：
```js
provide: function(){
    return {
        getMap: this.getMap,
    }
}
```

然后在任何后代组件中，都可以使用`inject`选项来接收指定的我们想要添加在这个实例上的属性`inject:['getMap']`

相比`$parent`来说，这个用法让我们在任意后代组件中访问`getMap`，而不需要暴露整个父组件实例。这允许我们更好地持续研发组件，而不需要担心我们可能会改变或移除一些子组件依赖的东西。同时这些组件之间的接口始终是明确的，就和`props`一样。

实际上，可以将依赖注入看做一部分”大范围有效的 prop“，除了：
1. 祖先组件不需要知道哪些后代组件使用它提供的属性
2. 后代组件不需要知道被注入的属性来自哪里

然而，依赖注入还是有负面影响的。它将你应用程序中的组件和它们当前的组织方式耦合起来了，使得重构变得困难。同时所提供的属性是非响应式的，这是出于设计的考虑，因为使用它们来创建一个中心化规模化的数据跟使用`$root`做这件事都是不够好的，如果你想要共享的这个属性是你应用特有的，而不是通用化的，或者如果你想在祖先组件中更新所提供的数据，那么这意味着你可能需要换用一个像 Vuex 这样真正的状态管理器方案了。

## 程序化事件监听器

目前已经有了`$emit()`用法，可以被`v-on`监听。但是 Vue 实例同时在其事件接口中提供了其他方法：
- 通过`$on(eventName, eventHandler)`侦听一个事件
- `$once(name,handler)`一次性侦听一个事件
- `$off(name,handler)`停止侦听一个事件

通常不会用到这些，但是当需要在一个组件实例上手动侦听事件的时候，它们是派的上用场的。

## 循环引用

递归组件

组件之间的循环引用

## 模板定义的替代方案

内联和 X-Template

## 控制更新

强制更新。`$forceUpdate`。

Vue 响应式系统始终知道何时进行更新，不过还是有一些边界情况。