# Hook

## 动机

Hook 解决了诸多问题：
### 组件之间复用状态逻辑很难

React 没有提供将可复用性行为“附加”到组件的途径（如将组件连接到`store`）。如果你用过 React 一段时间，也许会熟悉一些解决此类问题的方案。如`render props`和高阶组件。但是这类方案需要重新组织你的组件结构，这可能会很麻烦，使你的代码难以理解：React 需要为共享状态逻辑提供更好的原生途径。

你可以使用 Hook 从组件中提取状态逻辑，使得这些逻辑可以单独测试复用。Hook 使你在无需修改组件结构的状态下复用状态逻辑。
### 复杂组件变得难以理解
我们经常维护一些组件，组件起初很简单，但是逐渐会被状态逻辑和副作用充斥。每个生命周期常常包含一些不相关的逻辑。例如，组件常常在`componentDidMount`和`componentDidUpdate`中获取数据，但是同一个`componentDidMount`中可能也有很多其他逻辑。如设置监听而之后要在`componentWillUnmount`中清除。

在多数情况下，不可能将组件拆分为更小的粒度。因为状态逻辑无处不在，这也给测试带来了一定的挑战。同时这也是很多人将 React 和 状态管理库结合使用的原因之一。但是这往往带来了很多抽象的概念，需要你在不同的文件之间来回切换。使得复用变得更加困难。

为了解决这个问题，**Hook 将组件中相互关联的部分拆分为更小的函数**，而非强制按照生命周期划分。
### 难以理解的 class
除了代码复用和代码管理会遇到困难之外，还发现 class 是学习 React 的一大屏障。你必须理解 JavaScript 中`this`的工作方式，这与其他语言存在巨大差异。此外，class 也给目前的工具带来了一些问题，如 class 不能很好地压缩、并且 class 组件会无意中鼓励开发者使用一些让优化措施无效的方案。

为了解决这些问题，**Hook 使得你在非 class 的情况下可以使用更多的 React 特性**。
## 概览
### State Hook
`useState`，通过在函数组件中调用它来给组件添加一些内部`state`。React 会在重复渲染时保留这个`state`。`useState`会返回一对值：**当前**状态和一个让你更新它的函数，你可以在事件处理函数或其他地方调用这个函数，它类似`class`中的`this.setState`，但是它不会将新的`state`和旧的`state`合并。

`useState`唯一的参数就是初始 state，其只在第一次渲染中会被用到。
### Effect Hook
你可能已经在 React 中执行过数据获取、订阅或者手动修改 DOM。我们统一将这些操作称为**副作用**，或简称为**作用**

`useEffect`就是一个`Effect Hook`，给函数组件增加了操作副作用的能力。它与`class`组件中的`componentDidMount`等生命周期具有相同用途，只不过被合成了一个 API。

调用`useEffect`时，就是在告诉 React 在完成对 DOM 的更改后运行你的“副作用”函数。由于副作用函数是在组件内声明的，所以它们可以访问组件的`props`和`state`。默认情况下 React 会在每次渲染后调用副作用函数。

副作用函数还可以返回一个函数指定如何**清除**副作用，React 会在组件销毁时调用。
### 使用规则
- 只能在**函数最外层**调用 Hook。不要在循环、条件判断等中调用。
- 只能在**函数组件**中调用。
### 自定义 Hook
有时候我们会想要在组件之间复用一些状态逻辑。目前为止，有两种主流的方案解决这个问题：**高阶组件**和**render props**。自定义 Hook 可以让你在不增加组件的情况下达到同样的目的。

