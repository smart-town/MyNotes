# 迭代器与组合模式

**迭代器模式**，依赖于一个名为迭代器的接口。一旦有了这个接口，就可以为各种对象集合实现迭代器：数组、列表等等。

> **迭代器模式**提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。

这个模式给你提供了一种方法，可以顺序访问一个聚集对象中的元素，而又不用知道内部是如何表示的。在设计中使用迭代的影响是明显的：如果你有一个统一的方法访问聚合中的每一个对象，你就可以编写多态的代码和这些聚合搭配，使用了迭代器这个方法根本不用在意对象是由什么样的格式保存的。

另外一个对设计造成重要影响的是，迭代器模式把在元素之间游走的责任交给迭代器，而不是聚合对象。这不仅让聚合的接口和实现变得更加简洁，也可以让聚合更专注在它应该专注的事情上面（也就是管理对象集合）而不必理会遍历的事情。

## 单一责任

**一个类应该只有一个引起变化的原因**。

当我们允许一个类不但要完成自己的事情（如管理某种聚合），还同时要担负更多的责任（如遍历）时，我们就给了这个类两个变化的原因：如果这个集合改变的话，这个类也必须变化。如果我们遍历的方式改变的话，这个类也必须变化。

类的每个责任都有改变的潜在区域，超过一个责任意味着超过一个改变的区域。这个原则告诉我们尽量让每个类保持单一责任。

我们知道要避免类内部的改变因为修改代码很容易造成许多潜在的错误，如果有一个类具有两个改变的原因，那么这会使得将来该类的变化几率上升，当它真的改变时，你的设计中同时有两个方面将受到影响。

如何解决就在于将责任只指派该一个类，虽然听起来容易但是做起来并不简单：**区分设计中的责任是最困难的事情之一**。我们的大脑习惯看着一大群的行为然后将它们集中在一起，尽管它们可能属于两个或者多个不同的责任。想要成功的唯一方法就是努力检查设计，随着系统的成长随时观察有没有迹象显示某个类改变的原因超出一个。

### 内聚

**内聚**用来衡量一个类或者模块紧密地达到单一目的或责任。当一个模块或一个类被设计为只支持一组相关的功能时，我们说它具有**高内聚**，反之则是**低内聚**

内聚是一个比单一责任原则更普遍的概念，但是两者的关系其实是很密切的，遵循这个原则的类很容易具有很高的凝聚力，而且比背负许多责任的低内聚类更容易维护。

## 迭代器与集合

Java Collection Framework，一群类和接口。其中包括了`ArrayList`、`Vector`、`Stack`等。这些类都实现了`java.util.Collection`接口。这个接口包含了许多有用的方法，可以操纵一群对象。

`Collection`和`Iterator`的好处在于，每个`Collection`都知道如何创建自己的`Iterator`，只要调用`ArrayList`上的`iterator()`就可以返回一个具体的`iterator`而你根本不需要知道或者了解到底使用了哪个类。只需要使用它的`Iterator`接口就可以了。

### for/in

Java 5 包含的新语句，可以让你在一个集合或者数组中遍历，而且不需要**显式**创建迭代器

## 组合模式

> **组合模式**允许你将对象以树形结构来表现“整体/部分”层次结构。组合能够让客户以一致的方式处理个别对象以及组合对象。

以菜单为例：这个模式能够创建一个树形结构，在同一个结构中处理嵌套菜单和菜单项组。通过将菜单和项放在相同的结构中，我们创建了“整体/部分”结构，即由菜单和菜单项组成的对象树。一旦有了丰富的大菜单，我们就可以使用这个模式来“统一处理个别对象和组合对象”。意味着，如果我们拥有了一个树形的菜单、子菜单和可能还带有菜单项的子菜单。那么任何一个菜单都可能是一种“组合”。因为它既可以包含其他菜单，也可以包含菜单项。使用一个遵照组合模式的设计，让我们能够写出简单的代码。

### 认识

对于“一个类、一个责任”，组合模式却似乎是让一个类有两个责任的模式。组合模式不但要管理层次结构，还要执行菜单的操作。

可以这样说：**组合模式以单一责任设计原则换取透明性**。透明性？通过让组件的接口同时包含一些管理子节点和叶节点的操作，客户就可以将组合和叶节点一视同仁。也就是说，一个元素究竟是组合还是叶节点，对于用户而言是透明的。

因为客户有机会对一个元素作一些不恰当的或是没有意义的操作，所以我们失去了一些“安全性”。这是设计上的抉择，我们当然也可以采用另外一种方式：将责任区分开来放在不同的接口中，这样一来，设计上就比较安全。但是我们也因此失去了透明性。

这是一个很典型的折中案例。尽管我们受到设计原则上的指导，但是，我们总是需要观察某原则对于我们的设计所造成的影响。有时候我们可能会做一些看上去违反原则的事情。


