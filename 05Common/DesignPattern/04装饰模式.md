# 装饰模式

对扩展开放，而对改变关闭。

**装饰者模式**动态地将责任附加到对象上，如果要扩展功能，装饰者提供了比继承更具有弹性的替代方案。

- 装饰者和被装饰者具有相同的超类型
- 可以用一个或者多个装饰者包装同一个对象
- 既然装饰者和被装饰者具有相同的超类型，那么在任何需要原始类型（被包装的）的场合，可以用装饰过的对象代替它。
- 装饰者可以在所委托被装饰者的行为之前或者之后，加上自己的行为，以达到特定的目的！
- 对象可以在任何时候被装饰，所以可以在运行时动态地、不限量地用你喜欢的装饰者来装饰对象

## 继承和组合

这里装饰者需要继承被装饰者的超类型，以保持和被装饰者相同的超类。这里的继承是为了**类型匹配**，而不是利用继承**获得行为**

当将装饰者和组件组合的时候，就是加入新的行为，所得到的新行为，并不是继承得来的，而是由组合对象得来。

另外，通常装饰者模式采用的是抽象类，但是在 Java 中可以使用接口。不过要在原有的继承上修改的话就可以通过继承超类来达到装饰的目的。


## Java IO

java.io 中的类，很多都是装饰者。

如`FileInputStream`是一个可以被装饰的“组件”，Java IO 程序提供了几个组件包括：`FileInputStream`、`StringBufferInputStream`、`ByteArrayInputStream`...。这些类都提供了最基本的字节读取功能

而如`BufferedInputStream`则是一个具体的“装饰者”，它加入两种行为，利用缓冲输入来改善性能，用一个`readLine`方法增强接口。

## 问题

利用装饰者模式，常常会造成设计中会有大量的小类，可能造成使用的困扰。但是了解装饰者的工作原理之后，以后使用其他大量的装饰 API 时，就可以很容易的辨别出他们的装饰类是如何组织的，以方便的方式取得想要的行为。


如果将代码针对特定种类的具体组件，做一些特殊的事情。那么装饰者模式就会出问题。只有在针对抽象组件类型编程时才不会因为装饰者而受到影响。但是如果的确针对特定的具体组件编程，就应该重新思考你的应用程序架构是否适合装饰者模式


