# Linux 文本流

计算机中，所谓的数据即 0 或 1 序列。但是严格来说，Unix以**字节**作为数据的单位。也就是说这个序列的每 8 位为一个单位。利用 ASCII 编码，可以将这个字节转换为某个字符，所以在 Unix 中，数据完全可以用字符的形式表现出来，也就是所谓的**文本**。

实际上，如果以位为单位的话，计算机更容易读取和传输。但是 Unix 坚持以字节为单位来表示数据。原因在于，相对于以位为单位的二进制数据，以字节为单位文本直接就人类可读。这样的话，无论是计算机配置信息，还是别人写的诗，用户都可以直接读懂。当然并不是所有的数据都是设计让人来读懂的。很多编译好的可执行文件中包含的内容只有机器能读懂。打开这个文件尽管也能看到字符但是这些字符并不能组成什么有意义的文本。但是Unix并不会给这些“读不懂”的文件开后门，所有文件都是统一的形式，就能以相同的方式存储，也能共用一套处理工具，从而减少程序开发的难度。

存储文本的文件，相当于存储数据的一个个房子。在 Unix 的设计中，一向有 **“万物皆文件”**的说法，大部分的文件都对应了存储设备。就连表示文件位置的目录也是一种文件。此外程序的配置信息也都存储在文件中。对于 Unix 来说，文件可以广义地认为是提供或接收数据的对象。既然这样，Unix 干脆也把提供或者接收数据的硬件也表示成文件。这其中，既有外部连接的 USB 设备也有内部的内存硬件。在`/dev`目录下，可以看到很多这样代表硬件的文件。

但是托瓦兹对“万物皆文件”的说法做出了纠正。改为 **“万物皆文件流”**。系统运行时，数据并不是在一个文件中定居，数据会在 CPU 的指挥下源源不断地流动，就好像一个勤劳的上班族。有时候数据要到办公室上班，因此被读入内存。有时候去休假，传输到外部设备。在这样跑来跑去的过程中，数据像是排着队走的人流。我们叫他**文本流**。然而，计算机不同的设备之间链接方式差异很大，从内存到文件的连接像是爬山，从内存到外设像是游过一条河。为此，Unix定义了**流**,作为链接操作系统各处的公路标准，有了流，无论是从内存到外设还是从内存到文件所有的数据公路都是相同的格式。置于其他都交给操作系统处理。

## 标准输入、输出、错误 和重定向。

以上说明 Unix 的流的概念，连接操作系统各处。而操作系统以文件作为基础。即，流连接操作系统的各个文件。

当 Unix 执行一个程序的时候，自动打开三个流。**标准输入**、**标准输出**、**标准错误**。比如打开命令行的时候，默认情况下，命令行（文件A）的标准输入接到键盘(文件B)【也就是说文件B流到文件A?】标准输出和错误都链接到屏幕。对于一个程序来说，尽管它总会打开这三个流，但是它会根据情况使用。

**重新定向** `ls > a.txt`

**重新定向标准输出** `ls >> a.txt`

**改变标准输入** `cat < a.txt` 【cat 命令从标准输入读入文本并输出到标准输出】 `cat < a.txt > b.xt`复制了a

**同时定向标准输出和错误** `cd void  >& a.txt`

**重新定向标准错误** `cd void 2> a.txt`

## 管道

管道可以将一个命令的输出导向到另一个命令的输入。从而让两个（或者更多命令）像流水线一样连续工作，不断地处理文本流。用`|`表示管道

`cat < a.txt | wc` wc 命令代表 word count 用于统计文本中的行、词、字符总数。上面的命令表示 a.txt 文件内容先流入到 cat，然后从 cat 的标准输出流到 wc 的标准输入，从而 wc 知道了自己要处理的是 a.txt 文件。

Linux 各个命令实际上高度专业化，并尽量相互独立，每一个都只专注于一个小的功能。但是通过 `pipe` 可以将这些功能合在一起，实现一些复杂的目的。