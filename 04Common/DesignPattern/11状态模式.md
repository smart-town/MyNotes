# 状态模式

策略模式是围绕可以互换的算法来创建成功业务的，然而，状态走的是更加崇高的路，它通过改变对象内部的状态帮助对象控制自己的行为。

## 由来？

## 概念

> **状态模式**允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。

这个模式将状态封装为独立的类，并将动作委托给代表当前状态的对象。我们知道行为会随着内部状态而改变。

从客户的角度来看，如果说你使用的对象能够完全改变它自己的行为，那么你会觉得，这个对象实际上是从别的类实例化而来的。然而，实际上我们是使用组合通过简单引用不同的状态对象来造成类改变的家乡。

## 状态模式和策略模式

这两种模式的差别在于他们的“意图”

以状态模式而言，我们将一群行为封装在状态对象中，context 的行为可以随时委托到可委托到那些状态对象中的一个。随着时间的流逝，当前状态在状态对象集合中游走改变，以反映出 context 内部的状态。因此 context 的行为会发生改变。

而以策略模式而言，客户通常主动指定 Context 所要组合的策略对象是哪一个。显然，固然策略模式让我们具有弹性，能够在运行时改变策略，但是对于某个 context 对象来说，通常都是只有一个最适当的策略对象。

一般来说我们将策略模式想成是除了继承以外的一种弹性替代方案。如果你使用了继承定义一个类的行为，你将被这个行为困住，甚至要修改它都很难，有了策略模式你可以通过组合不同的对象来改变行为。

我们将状态模式想成是不用在 context 中放置许多条件判断的替代方案，通过将行为包装到对象中，你可以通过在 context 内简单地改变状态对象来改变 context 行为。

## 认识

一般来讲，当状态转换固定的时候，适合放在`Context`中；然而当转换更动态的时候，通常就会放在状态类中。将状态转换放在状态类中的缺点是：状态类之间产生了依赖。

注意：在做决策的同时，也等于在为另一件事情做决策：当系统进化时，究竟哪个类是对修改封闭。

在这一模式中，客户不会和状态交互。状态是用在`context`内部代表它的状态以及行为的，客户根本不会了解

另外，在个别的状态类中封装状态行为，结果总是增加这个设计中的类的数目。这就是为了要获取弹性而付出的代价。除非你的代码是一次性的，可以用完就扔掉。那么其实状态模式的设计绝对是值得的，其实真正重要的是你暴露给客户的类数目。如果你有一个应用，它有很多状态，但是你决定不将这些状态封装在不同的对象中，那么你就会得到巨大的、整块的条件语句，这会让你的代码变得不容易理解和维护。通过使用许多状态对象，可以让状态变得很干净，以后理解和维护时可以省下很多功夫。

