# 适配器模式和外观模式

## 适配器认识

使用适配器过程：
- 客户通过目标接口调用适配器的方法对适配器发送请求
- 适配器使用被适配者接口将请求转换为被适配者的一个或者多个接口
- 客户接收到调用的结果，但是并未察觉到这是适配器在起转换作用

实现一个适配器所需要进行的工作，和目标接口的大小成正比。如果不使用适配器，就必须改写客户端的代码来调用这个新的接口，将会花费许多力气来做大量的调查和代码改写工作。
相比之下，提供一个适配器类将所有的改变封装在一个类中，是一个比较好的做法。

适配器模式的工作是将一个接口转换为另一个，虽然大多数的适配器模式所采取的例子都是让一个适配器包装一个被适配者，但是明显现实世界复杂多了，所以可能会遇到一些现实情况，需要让一个适配器包装多个被适配者。

这涉及到另外一个模式，被称为**外观模式**。

另外，当系统中需要使用到两种不同的接口，可以让旧的接口依旧沿用。可以创建一种**双向适配器**，实现所涉及到的**两个接口**，这个适配器可以当做旧的接口或当做新的接口使用。

### 适配器概念

> **适配器模式**将一个类的接口，转换成为客户期望的另外一个接口，适配器让原本接口不兼容的类可以合作无间

这个模式可以通过创建适配器类进行接口转换，让不兼容变成兼容，这可以让客户从实现的接口解耦。如果在一段时间之后，想要改变接口，适配器可以将改变的部分封装起来，客户就不必为了应对不同的接口而每次跟着修改。

适配器模式包含着良好的 OO 原则：使用对象组合，以修改的接口包装被适配者：这种做法还有额外的优点，即适配者的任何子类都可以搭配着适配器使用。

也需要留意，这个模式如何将客户和接口绑定起来，而不是和实现绑定。我们可以使用数个适配器，每一个都负责转换不同组的后台类，或者也可以加上新的实现，只要它们遵守目标接口即可。

### 对象和类的适配器

实际上有两种适配器：“对象适配器”和“类”适配器。“类”适配器需要使用多重继承才能够实现它，这在 Java 中是不可能的。但是当使用多重继承语言时还是有可能遇到这样的需求的，如`Adapter extends Target,Adaptee`

差别在于类适配器继承了 Target 和 Adaptee，而对象适配器利用组合的方式将请求传送给适配者。

### 实际适配器

迭代器：`Iterator`接口。这个接口让你可以遍历此集合类型内的每个元素。迭代器：`Enumeration`旧的接口，依然可以遍历集合中的每一个元素而无需知道它在集合内是被如何管理的。如果要适配旧代码中的`Enumerator`(旧的代码只暴露了枚举器接口，而我们又希望在新的代码中只使用迭代器)：
```java
public class EnumeratorAdapter implements Iterator {
    Enumeration enum ;
    public EnumeratorAdapter(Enumeration enum){this.enum = enum;}
    public boolean hasNext(){return enum.hasMoreElements();}
    public Object next(){return enum.nextElement();}
    public void remove(){throw new UnsupportedOperationException();}
}
```

### 和装饰者的区别

事情一旦涉及到装饰者就表示有一些新的行为或者责任要加入到你的设计中，而适配器只是**转换接口**。装饰器和适配器都包装了对象，不过装饰器的工作更多是**扩展包装对象的行为或者责任**。

## 外观模式认识

其改变接口的原因是**为了简化接口**，之所以称为**外观模式**，因为它将一个或者多个类的复杂都隐藏在背后，只显露出一个干净简单的外观。

外观不会**封装**子系统的类，只是提供了简化的接口，所以如果觉得有必要还是可以直接使用子系统的类：提供简化接口的同时，依然将系统完整的功能暴露出来，以供需要的人使用。

### 外观模式概念

> **外观模式**提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。

务必记得模式的**意图**。是为了提供简单的接口好让一个子系统更易于使用。

### 最少知识原则

`Least Knowledge`原则告诉我们要减少对象之间的交互。“只和你的密友谈话”。意味着，当你设计一个系统的时候，不管是任何对象，你都要注意到它所交互的类有哪些，并注意它是如何和这些类进行交互的。

这个原则希望我们在设计中，不要让太多类耦合在一起。免得修改系统中的一部分会影响到其他部分。如果许多类之间相互依赖，那么这个系统就变成一个易碎的系统，它需要花费许多成本去维护，也会因为太复杂而不容易被其他人了解。

####  方针

就任何对象而言，在该对象的方法内，我们应该只调用属于以下范围的方法：
- 该对象本身
- 被当做方法参数传递进来的对象
- 此方法所创建或实例化的任何对象
- 对象的任何组件

### 缺点

虽然该原则减少了对象之间的依赖，但是研究显示这会减少软件的维护成本。但是采用这个原则也会导致更多的“包装”类被制造出来，以处理和其他组件的沟通。这可能导致复杂度和开发时间的增加，并降低运行时的性能。

