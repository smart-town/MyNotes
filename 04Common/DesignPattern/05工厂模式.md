# 工厂模式

设计原则之一就是“针对接口编程，而不是针对实现编程”，但是通常情况下，`new`操作符总是针对实现的。

存在一种情况：有一些要实例化的具体类，但是究竟实例化哪个类，则在运行时由一些条件来决定。

真正的问题在于“改变”。针对接口编程，可以隔离掉以后系统可能发生的一大堆改变，为什么呢？如果代码时针对接口而写的，那么通过多态。他可以与任何新类实现该接口，但是当代码中存在大量类的时候，一旦加入新的类，就必须改变代码。也就是说，你的代码并非“对修改关闭”，想要用新类扩展代码，就必须重新打开它。所以该怎么办呢？要记得设计原则中有一条就是“找出会变化的部分，将它们从不变的部分抽离出来”。

如果我们知道哪些会改变，哪些不会改变，就是使用**封装**的时候了。

## 封装创建对象的代码

**工厂**处理创建对象的细节。

### 静态工厂

利用静态方式创建一个简单的工厂，其缺点在于不能通过继承来改变创建方法的行为。

### 简单工厂

简单工厂模式其实不是一个设计模式，更像是一种编程习惯。但是由于经常使用，所以也姑且认为是一种设计模式。

*需要依靠某事物做一定的事，步骤确定，但是该事物可能在不同情况下会有不同的选择*

### 工厂模式

对于简单工厂模式而言，你需要选择一个工厂来根据实际情况选择一个具体实现。然后依赖于多态，让其按照一个既定的一系列步骤完成一个工作。

即对于 pizza 店的例子来说，生产 pizza 的步骤是一致的，但是生产什么类型的 pizza 则依赖于工厂模式。

可是随着实际情况的发展，有可能 pizza 店扩张，你需要让其他 pizza 店利用同样的生产步骤。不过由于地理位置的不同，虽然步骤相同，但是具体步骤的实际细节却有所变化。

其实质可能在于，*步骤一定，对于某一特定条件，因为工厂不同，所作出的判断也不同。*

通常，工厂方法遵循这样的格式`abstract Product factoryMethod(String type)`，工厂方法是抽象的，必须返回一个产品，超类中定义的方法，通常使用到工厂方法的返回值。工厂方法将客户（也就是超类中的代码）和实际创建具体产品的代码分离开来。工厂方法可能需要参数，也可能不需要。

### 抽象工厂模式

另外一种情况，纯粹的工厂？只是纯粹地生产**产品**，可能不止一种产品。抽象工厂让客户使用抽象的接口创建一组相关的产品，而不用知道或关心实际产出的产品是什么。这样一来，客户就会从具体的产品中被解耦出来。

其实，对于一组产品来说，每组产品的产生可能都会使用**工厂模式**，而抽象工厂是对其的组合。



## 概念

所有工厂模式都用来封装对象的创建，**工厂方法模式**通过让子类决定该创建的对象是什么，来达到将该对象创建的过程封装的目的。

**创建者类**，抽象创建者类通常会定义一个抽象的工厂方法，让子类实现此方法制造产品。创建者通常也会包含依赖于抽象产品的代码，而这些抽象产品由子类制造。创建者不需要知道在制造哪种具体产品。

**产品类**。

> **工厂方法模式**定义了一个创建对象的接口，但是由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。

> **抽象工厂模式** 提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。

## 依赖倒置原则

依赖倒置原则。*要依赖抽象不依赖具体类*

不能让高层组件依赖低层组件，而且不管是低层组件还是高层组件，两者都应该依赖于抽象。所谓高层组件，是由其他低层组件定义其行为的类。

这里的**倒置**，体现在，和一般的 OO 设计思考方式完全相反，低层组件依赖于高层的抽象。同样地，高层组件也在依赖相同的抽象。

### 指导规则

- 变量不可以持有具体类的引用
- 不要让类派生自具体类
- 不要覆盖基类中已经实现的方法
    **如果覆盖基类已经实现的方法，那么你的基类就不是一个真正适合被继承的抽象，基类中已经有实现的方法，应该由所有子类共享**

当然，只是尽量达到这个原则。而不是随时都要遵循这个原则。但是，如果深入体验这些方针，将这些方针内化为思考的一部分。那么在设计时就有足够的理由违反这样的原则。比如，如果有一个不像是会改变的类，那么在代码中直接实例化也就没有什么大碍，想想看，平时在程序中不就是经常实例化字符串对象吗？当然违反了这个原则，但是可以这么做！因为字符串不可能改变。

另一方面，如果一个类有可能改变，你可以采用一些好的技巧（如工厂模式）封装改变。

