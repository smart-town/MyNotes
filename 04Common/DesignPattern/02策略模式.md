# 策略模式

Strategy Pattern。**策略模式**定义了算法族，分别封装起来，让它们之间可以相互替换。此模式让算法的变化独立于算法的客户。

## 实例

《HeadFirst 设计模式》中的鸭子案例。

最初：假设有一个类`Duck`，具体的鸭子类继承于该类`Duck`，具体的有如绿头鸭、模型鸭、橡皮鸭等等。

问题产生：随着需求变化，假设之后需要给鸭子增加飞行行为。如果直接给`Duck`类增加飞行行为，那么所有的具体类都会具有飞行行为，但是问题在于，橡皮鸭可能不会飞！此时是将具体的实现放到了父类`Duck`中。这显然不是一个好的做法。

解决: 将飞行行为抽离出来来应对各种`Duck`具体实现的不同需求，即会飞或者不会飞，甚至以什么样的方式飞。将飞行行为设计为接口`Fly`，利用多态的特性。在`Duck`中增加一个`Fly`接口的实例域，具体实现的`Duck`类指定某一个具体的`Fly`接口实现，并调用其飞行方法，实现自定义的飞行。

--------

生活中常常会有实现某种目标存在多种策略可供选择的情况，如出门旅行可以乘坐飞机、火车等；超市促销可以打折、送商品等。

软件开发中也经常遇到类似情况。当实现某个功能存在多种算法或者策略时，我们可以根据环境或者条件的不同选择不同的算法策略来完成功能。如数据排序有冒泡排序、选择排序等。

如果使用多重条件转移语句实现，不但使得条件语句变得很复杂，而且增加、删除或者更换算法要修改原代码，不易维护，违背开闭原则。

## 定义和特点

Strategy: 该模式定义了一系列算法，并将每个算法封装起来，使得它们可以相互替换，且算法的变化不会影响使用算法的客户。

策略模式属于对象行为模式，它通过对算法的封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。

### 优点

1. 多重条件语句不易维护，使用策略模式可以避免
2. 策略模式提供了一系列可供重用的算法族，恰当使用继承可以将算法族的公共代码转移到父类中，从而避免重复的代码
3. 策略模式提供相同行为的不同实现，客户可以根据不同时间或空间要求选择不同的
4. 策略模式提供对开闭原则的完美支持，可以在不修改原代码的情况下，灵活增加新算法。
5. 策略模式把算法的使用放到环境类中，而算法的实现转移到具体策略类中，实现了二者的分离

### 缺点

1. 客户端必须理解所有策略算法的区别
2. 策略模式造成很多的策略类

## 结构

1. 抽象策略类：定义一个公共接口，各种不同的算法以不同的方式实现这个接口，环境角色使用这个接口调用不同的算法，一般使用接口或者抽象类实现
2. 具体策略类：实现了抽象策略类提供的接口，提供具体的算法实现
3. 环境类(Context): 持有一个策略类的引用，最终给客户端调用