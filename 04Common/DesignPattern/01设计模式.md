# 设计模式

## 是什么

## OO 原则

### 一 封装变化

找出应用中可能需要变化的地方，将他们独立出来，不要和那些不需要变化的代码混合在一起。

或者说，如果每次新的需求一来，都会使得某方面的代码发生变化，那么就可以确定，这部分的代码需要抽取出来，和其他稳定的代码有所区分。

另外一种思考方式、将会变化的部分封装起来，以便以后可以轻易地改变或者扩充此部分，而不影响需要变化的其他部分。

### 二 针对接口

针对接口编程而不是针对实现编程

### 三 多用组合，少用继承

将两个类结合起来使用而非**继承**

使用组合建立系统具有很大的弹性，不仅可以将算法**封装成类**，更可以**在运行时动态改变行为**，只要组合的行为对象符合正确的接口标准即可。

### 四 松耦合

松耦合。为了交互对象之间的松耦合设计而努力。

### 五 对扩展开放，对修改关闭

允许类容易扩展，在不修改现有代码的前提下，就可以搭配新的行为。如果实现这样的目标，这样的设计就具有弹性可以应对改变，可以接受新的功能来应对改变的需求。

### 六 依赖倒置原则

*要依赖抽象不依赖具体类*

不能让高层组件依赖低层组件，而且不管是低层组件还是高层组件，两者都应该依赖于抽象。所谓高层组件，是由其他低层组件定义其行为的类。

这里的**倒置**，体现在，和一般的 OO 设计思考方式完全相反，低层组件依赖于高层的抽象。同样地，高层组件也在依赖相同的抽象。

### 七 单一责任

类应该只有一个改变的原因。

当我们允许一个类不但要完成自己的事情（如管理某种聚合），还同时要担负更多的责任（如遍历）时，我们就给了这个类两个变化的原因：如果这个集合改变的话，这个类也必须变化。如果我们遍历的方式改变的话，这个类也必须变化。

类的每个责任都有改变的潜在区域，超过一个责任意味着超过一个改变的区域。这个原则告诉我们尽量让每个类保持单一责任。

我们知道要避免类内部的改变因为修改代码很容易造成许多潜在的错误，如果有一个类具有两个改变的原因，那么这会使得将来该类的变化几率上升，当它真的改变时，你的设计中同时有两个方面将受到影响。

如何解决就在于将责任只指派该一个类，虽然听起来容易但是做起来并不简单：**区分设计中的责任是最困难的事情之一**。我们的大脑习惯看着一大群的行为然后将它们集中在一起，尽管它们可能属于两个或者多个不同的责任。想要成功的唯一方法就是努力检查设计，随着系统的成长随时观察有没有迹象显示某个类改变的原因超出一个。

### 八 好莱坞原则

> 别调用（打电话给）我们，我们会调用（打电话）给你

好莱坞原则可以给我们一种防止**依赖腐败**的方法，当高层组件依赖低层组件，而低层组件又依赖高层组件时，而高层组件又依赖边侧组件，边侧组件又依赖低层组件时，依赖腐败就发生了。这种情况下，很难搞懂系统是如何设计的。

在好莱坞原则之下，我们允许低层组件将自己挂钩到系统上，但是高层组件会决定什么时候和怎样使用这些低层组件。换句话说，高层组件对待低层组件的方式是“别调用我们，我们调用你”。

低层组件可以参与计算，但是绝对不可以直接调用高层组件。高层组件可以控制如何以及何时让低层组件参与。

## 如何使用

我们都在使用别人设计好的库与框架，我们讨论库与框架、利用它们的 API 编译成我们的程序、享受运用别人代码带来的优点。就如 Java API 带来的网络、GUI、IO 等功能。库与框架长久以来，一直扮演者重要的角色，我们从其中挑选需要的组件，将它们放到合适的地方。但是，库和框架并不能帮助我们将应用组织成容易了解、容易维护、具有弹性的架构。所以需要设计模式。

设计模式不会直接进入代码中，而是先进入你的“大脑”中。一旦在脑海中有了许多关于模式的知识，就能够在新设计中采用它们。

