# 观察者模式

帮助对象知悉现状，不会错过该对象感兴趣的事情。对象甚至可以在运行期间可以决定是否要继续被通知。观察者模式是 JDK 中使用的最多的模式之一，非常有用。

## 认识

报纸和杂志的订阅：
1. 报社的业务就是出版报纸
2. 向某家报社订阅报纸，只要有新报纸出版就会给你送来，只要你是订阅用户
3. 不想看报纸时取消订阅就不会再送新报纸来
4. 只要报社在运营，就会有人或单位向他们订阅或取消

出版者+订阅者=观察者模式

**主题对象**管理某些数据，当主题中的数据改变就会通知**观察者**。而观察者**订阅**主题以便在主题数据改变时收到更新。

## 定义观察者模式

>**观察者模式**定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它所有的依赖者都会收到通知并自动更新。

主题和观察者定义了一对多的关系，观察者依赖主题，只要主题一有状态变化，观察者就会被通知，根据通知的风格，观察者可能因此值更新而更新。

实现观察者模式的方式不止一种，但是以`Subject`和`Observer`接口的类设计做法最为常见。

具体实现时，定义主题接口和观察者接口。主题接口可以有多个观察者。其本身可以增加或者删除观察者，并且会有一个方法专门用来通知观察者。而观察者会有一个`update`方法，当主题改变时它会被调用。

## 松耦合

观察者模式提供了一种对象设计，让主题和观察者之间松耦合。

关于观察者的一切，主题只知道观察者实现了某个接口（Observer），主题不需要知道观察者的具体类是谁，做了什么或者其他细节。

任何时候我们都可以增加新的观察者，因为主题唯一依赖的东西是一个实现`Observer`接口的对象列表。所以我们可以随时增加观察者。事实上，在运行时我们可以用新的观察者取代现有的观察者，主题不会受到任何影响。同样也可以在任何时候删除某些观察者。

当有新的观察者出现时，主题的代码不需要更改。假设我们有了一个新的具体类需要当观察者，我们不需要为了兼容所有新类型而修改主题的代码，所有要做的只是在新的类里实现此观察者接口，然后注册为观察者即可。

我们可独立复用主题或观察者，如果我们在其他地方需要使用观察者和主题，可以轻易复用，因为二者并非紧密耦合。

松耦合的设计能让我们建立有弹性的 OO 系统，能够应对变化，因为对象之间的依赖关系降低到了最低。

## 关于获取数据

主题可以主动推送通知给观察者。但是也可以让观察者自己在需要的时候主动**获取**最新数据。

## 理解

观察者会拥有一份属于自己的 Observer 引用列表，当数据发生改变后，通过某一方法遍历这个列表并调用所有 Observer 对象的 update 方法，由于每个 update 由各个 Observer 自己实现，因此它们会获得各自需要的数据，如何处理由它们自己决定。

## 使用 Java 内置的观察者模式

Java API 内置有观察者模式。`java.util`包中含有最基本的`Observer`接口与`Observable`类。

`Observable`类追踪所有的观察者，并通知它们。

具体使用时，可以通过继承`Observable`类来成为“可观察者”。此时就不需要实现`register()`等方法了。

### 可观察者如何送出通知

1. 首先调用`setChanged()`标记出状态已经更改
2. 调用`notifyObservers()`或`notifyObservers(Object arg)`

### 观察者如何接收

观察者实现更新方法：`update(Observable o, Object arg)`。主题本身当做第一个变量，好让观察者知道是哪个主题通知它的。后者则是传入`nofityObservers()`中的对象。

如果你想要推送数据给观察者，就可以将数据当做对象传递给`notifyObservers(args)`方法，否则，观察者就必须自己从可观察者对象中拉取数据。

### 关于 setChanged()

`setChanged()`方法用来标记状态已经改变的事实，好让`notifyObservers()`知道当他被调用时应该更新观察者，如果调用`notifyObservers()`之前没有先调用`setChanged`，观察者就不会被“通知”。

这样做是有其必要性的，`setChanged()`方法可以让你更新观察者时，有更多的弹性。可以在适当地时候通知观察者。比如数据变化范围很大时才通知。

对应有`clearChanged()`方法

### 不要依赖观察者被通知的次序

`java.util.Observable`实现了它的`notifyObservers()`方法。我们并不知道它是如何做出的通知次序。可以确定的是如果依赖这样的次序，很可能就会出错。因为一旦观察者/可观察者的实现改变，通知次序就会改变，很可能产生错误结果。

### 问题所在

`java.util.Observable`是一个“类”而不是“接口”。真因为如此，你必须设计一个类继承他，如果某类想要同时具有`Observable`和另一个超类的行为。就会陷入困难，毕竟 Java 不支持多重继承。（这增加了 Observable 的复用潜力）。另外，因为没有`Observable`接口，所以无法建立自己的实现，和内置的`Observer API`搭配使用。

## 如何符合设计原则？

### 封装变化

### 针对接口而非实现编程

### 使用组合而非继承

### 松耦合
