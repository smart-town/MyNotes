# HTML 解析器

HTML 解析器的任务是将 HTML 标记解析成解析树。

## 非上下文无关语法

语法可以用 BNF 等格式进行定义。但是很遗憾，所有常规的解析器都不适用于 HTML。HTML 并不能很容易地用解析器所需的上下文无关的语法来定义。

有一种可以定义 HTML 的正规格式：DTD(Document Type Definition)。文档类型定义。但是它不是上下文无关的语法。

这初看起来很奇怪，HTML 和 XML 非常相似，有很多 XML 解析器可以使用。 HTML 存在一个 XML(XHTML) 变体，那么有什么大的区别呢？

区别在于 HTML 处理更加“宽容”。它允许你省略某些隐式添加的标记，有时候还能省略一些起始或结束标记等。和 XML 严格的语法不同，HTML 整体看起来是一种“软性”的语法。

显然这种看上去细微的差别实际上带来了巨大的影响。一方面这是 HTML 如此流行的原因：它能包容你的错误，简化网络开发。另一方面，这使得它很难编写正式的语法。概括地说，HTML 无法很容易地通过常规解析器解析（因为它的语法不是与上下文无关的语法），也无法通过 XML 解析器解析。

## DOM

解析器的输出“解析树”是由 DOM 元素和属性节点构成的树结构。DOM 是文档对象模型（Document Object Model）的缩写。它是 HTML 文档的对象表示。同时也是外部内容如 JavaScript 与 HTML 元素之间的接口。解析树的根节点是 `Document` 对象。

DOM 与标记之间几乎是一一对应的关系。

## 解析算法

上面有说，HTML 无法用常规的自上而下或自下而上的解析器进行解析。原因在于：
- 语言的宽容本质
- 浏览器历来对一些常见的无效 HTML 用法保持宽容态度
- 解析过程需要不断往复，源内容在解析过程中通常不会改变，但是在 HTML 中，脚本标记如果包含`document.write`就会添加额外标记，这样解析过程实际就更改了解析内容。

由于不能使用常规的解析技术，浏览器就创建了自定义的解析器来解析 HTML。

此算法由两个阶段组成：**标记化**和**树构建**

标记化是词法分析过程，将输入内容解析为多个标记。HTML 标记包括起始标记、结束标记、属性名称和属性值。

标记生成器识别标记，传递给树构造器，然后接收下一个字符以识别下一个标记；如此反复直到输入的结束。

### 标记化算法

该算法的输出结果是 HTML 标记，该算法使用状态机表示。每一个状态接收来自输入信息流的一个或多个字符，并根据这些字符更新下一个状态。当前的标记化状态和树结构状态会影响进入下一个状态的决定。这意味着，即使接收的字符相同，对于下一个正确的状态也会产生不同的结果。具体取决于当前的状态。该算法相当复杂，无法在此详述。

基本示例：将以下的 HTML 代码标记化：
```html
<html>
    <body>
        Hello World!
    </body>
</html>
```
初始状态是数据状态，遇到字符`<`时，状态更改为**标记打开状态**。接收一个`a-z`字符会创建**起始标记**，状态更改为**标记名称状态**。这个状态会一直保持到接收`>`字符。在此期间接收的每个字符都会附加到新的标记名称上。在这里我们创建的是`html`标记。

遇到`>`时，会发送当前的标记，状态改回为**数据状态**，`<body>`标记随后进行同样的处理。目前`html`和`body`标记均已发出。现在回到**数据状态**，接收到`Hello World!`中的`H`字符，将创建并发送字符标记，直到接收到`</body>`中的`<`，我们将`Hello World!`中的每个字符都发送一个字符标记。

现在我们回到**标记打开状态**，接收到`/`字符时，会创建`end tag token`并改名为**标记名称状态**。我们会保持这个状态，直到接收到`>`，然后发送新的标记，并回到数据状态。`</html>`也会做同样的处理。

### 树构建算法

在创建解析器的同时，也会创建`Document`对象。在树构建阶段，以`Document`为根节点的的 DOM 树也会不断进行修改，向其中添加各种元素。标记生成器发送的每个节点都会由树构建起进行处理。规范中定义了每个标记所对应的 DOM 元素，这些元素会在接收到相应的标记时创建。这些元素不仅会添加到 DOM 树中，还会添加到开放元素的堆栈中。此堆栈用于纠正嵌套错误和处理未关闭的标记。其算法也可以用状态机来描述，这些状态称为**插入模式**

示例输入的树构建构成：

树构建阶段的输入是一个来自标记化阶段的标记序列，第一个模式是`initial mode`，接收 HTML 标记后转为`before html`模式，并在这个模式下重新处理此标记。这样会创建一个`HTMLElement`元素，并将其附加到`Document`根对象上。

然后状态改为`before head`，此时我们接收到`body`标记，即使我们的示例中没有`head`标记，系统也会隐式创建一个`HTMLHeadElement`，并将其添加到树中。

现在进入了`in head`模式，然后转入`after head`模式，系统对`body`标记进行重新处理。创建并插入`HTMLBodyElement`，同时模式转为`in body`

现在接受由`Hello Word!`字符串生成的一系列字符标记，接收第一个字符时会创建并插入`Text`节点，而其他字符也会附加到该节点。

接收`body`结束标记会触发`after body`模式，现在我们将接收到`HTML`结束标记，进入`after after body`模式。接收到文件结束标记后，解析过程就此结束。

## 解析之后的操作

在此阶段，浏览器会将文档标注为交互状态。并开始解析那些处于`deffered`模式的脚本，也就是那些应该文档解析完成之后才执行的脚本。然后，文档状态将设置为“完成”，一个**加载**事件也将随之触发。

## 浏览器的容错机制

你在浏览 HTML 网页时从来不会看到语法无效的错误，这是因为浏览器会纠正任何语法无效内容，然后继续工作。

## 处理脚本和样式表的顺序

### 脚本

网络的模型是同步的。网页作者希望解析器遇到`<script>`标签时立即解析并执行脚本。文档的解析将停止，直到脚本解析完毕。如果脚本是外部的，那么解析过程会停止，直到从网络同步抓取资源完成后再继续。此模型已经使用了多年。作者也可以将脚本标注为`defer`，这样它就不会停止文档解析，而是等到解析结束后才执行。HTML5 增加了一个选项，可以将脚本标记为异步，以便由其他线程解析和执行。

### 预解析

Webkit 和 Firefox 都进行了这项优化。在执行脚本时，其他线程会解析文档的其余部分。找出并加载需要通过网络加载的其他资源。通过这种方式，资源可以在并行连接上加载。从而提高总体速度。请注意，预解析器并不会修改 DOM 树，而是将这项工作交由主解析器处理；预解析器只会解析外部资源（如外部脚本、样式表）的引用

### 样式表

另一方面，样式表有着不同的模型。理论上来说，应用样式表不会更改 DOM 树，因此没有必要等待样式表并停止文档解析。但是这涉及到一个问题，就是脚本在文档解析阶段会请求样式信息。如果当时还没有加载和解析样式，脚本就会获得错误的回复。这样显然会产生很多问题。这看上去是一个非典型案例，但是实际上非常普遍。Firefox 会在样式表加载和解析过程中，禁止所有脚本。而对于 Webkit 而言，仅当脚本尝试访问的样式属性可能受到尚未加载的样式表影响时，它才会禁止该脚本。