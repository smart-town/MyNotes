# 绘制

在绘制阶段，系统会遍历呈现树，并调用呈现器的`paint`方法。将呈现器的内容绘制到屏幕上。绘制工作是**使用用户界面基础组件**完成的。

## 全局绘制和增量绘制

和布局一样，绘制也分为全局和增量两种。在增量绘制中，部分呈现器发生了更改，但是不会影响到整个树。更改后的呈现器将其在屏幕上对应的矩形区域设置为无效。这导致 OS 将其视为一块`dirty`区域，并生成`paint`事件。OS 会很巧妙地将多个区域合并为一个。在 Chrome 浏览器中，情况要更复杂一些。因为 Chrome 浏览器的呈现器不在主进程中。Chrome 浏览器会在某种程度上模拟 OS 的行为。展示层会侦听这些事件，并将消息委托给根节点。然后遍历呈现树，直到找到相关的呈现器，该呈现器会重新绘制自己。（通常也包括其子代）

## 绘制顺序

绘制的顺序其实就是元素进入堆栈样式上下文的顺序。这些堆栈会从后往前绘制，因此这样的顺序会影响绘制，块呈现器的堆栈顺序如下：
1. 背景颜色
2. 背景图片
3. 边框
4. 子代
5. 轮廓

## Firefox 显示列表

Firefox 遍历整个呈现树，为绘制的矩形建立一个显示列表。列表中按照正确的绘制顺序包含了与矩形相关的呈现器。这样等到重新绘制的时候，只需要遍历一次呈现树，而不用多次遍历（绘制所有背景，然后绘制所有图片，再绘制所有边框等）

Firefox 对此过程进行了优化。也就是不添加隐藏的元素。例如被不透明元素完全遮挡的元素

## Webkit 矩形存储

在重新绘制之前，Webkit 会将原来的矩形另存为一张位图，然后只绘制新旧矩形之间的差异部分。

## 动态变化

在发生变化时，浏览器会尽可能作出最小的响应。因此，元素的颜色改变后，只会对该元素进行重绘。元素的位置改变后，只会对该元素及其子元素（可能还有同级元素）进行布局和重绘。添加 DOM 节点后，会对该节点进行布局和重绘。一些重大变化如增加 html 字体，会导致缓存无效，使得整个呈现树都进行重新布局和绘制。

