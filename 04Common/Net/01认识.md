# 认识

HTTP 是一种能够获取如 HTML 这样的网络资源的 protocol。它是在 Web 上进行数据交换的基础，是一种 client-server 协议。

一个完整的 Web 文档通常是由不同的子文档拼接而成的，像是文本、布局描述、图片、视频等。

## 基于HTTP的组件系统

HTTP 是一个 client-server 协议，请求通过一个实体被发出。实体也就是用户代理，大多数情况下，这个用户代理都是指浏览器。当然它也可能是任何东西，比如一个爬取网页生成维护搜索引擎的爬虫。

每一个发送到服务器的请求，都会被服务器处理并返回一个消息。在这个请求和响应的中间，还有许许多多的被称为`proxies`的实体，它们的作用和表现各不相同，比如有些是网关，还有些是 cache 等。

实际上，在一个浏览器和处理请求的服务器之间，还有路由器、调制解调器等许多计算机，由于 web 的层次设计，那些在网络层和传输层的细节都被隐藏起来了。HTTP 位于最上层的应用层。虽然底层对于分析网络问题非常重要但是大多都和 HTTP 的描述不相干。

### user-agent

user-agent 就是任何能够为用户发起行为的工具，这个角色通常用浏览器来扮演。一些例外的情况比如工程师使用的程序，以及 Web 开发人员的调试应用程序。

浏览器总是作为一个发起请求的实体，它永远不是服务器。要展现一个网页，浏览器首先发送一个请求来获取页面的 HTML 文档。再解析文档中的资源信息发送其他请求，获取可执行的脚本或者 css 样式进行页面渲染。以及其他一些页面资源如图片和视频。然后浏览器将这些资源整合到一起，展现出一个更完整的文档，也就是网页。浏览器执行的脚本可以在之后的阶段获取更多的资源，并相应地更新网页。

一个网页就是一个超文本文档。也就是说，有一部分显示的文本可能是超链接，启动它就可以获取一个新的网页。

### web 服务端

上述的通信过程的另一端，是由 web server 来服务并提供客户端所请求的文档。Server 只是虚拟意义上代表一个机器： 它可以是共享负载（负载均衡）的一组服务器组成的计算机集群，也可以是一组复杂的软件通过向其他计算机发起请求来获取部分或全部资源。

### 代理

在浏览器和服务器之间，有许多计算机和其他设备转发了 HTTP 消息。由于 web 栈层次的原因，它们大多数都出现在传输层、网络层、物理层，对于 HTTP 应用层而言是透明的。虽然它们可能对应用层性能有重要影响。还有一部分是表现在应用层上的，被称为**代理 Proxies**，代理既可以表现得透明、又可以不透明。

- 缓存（可以是公开的也可以是私有的，像浏览器的缓存）
- 过滤（如反病毒扫描）
- 负载均衡（让多个服务器服务不同的请求）
- 认证（对不同的资源进行权限管理）
- 日志记录（允许存储历史信息）

## HTTP 的基本性质

### 简单的、可扩展的

虽然下一代 HTTP/2 协议将 HTTP 消息封装到了帧中，但是 HTTP 大体上还是被设计得简单易懂，HTTP 报文能够被人读懂，还允许简单测试。

在 HTTP/1.0 中出现的 HTTP headers 让协议扩展变得非常容易，只要服务端和客户端就 headers 达成了语义一致，新功能就可以轻松加进来。


### HTTP 是无状态的，有会话的

HTTP 是无状态的：在同一个连接中，两个执行成功的请求之间是没有关系的，这就带来了一个问题，用户没有办法在同一个网站进行连续的交互，比如在一个电商网站里，用户将某个商品加入到购物车，切换页面后再次添加了商品，这两次添加的请求之间没有关联，浏览器无法知道用户最终选择了哪些商品。而使用 HTTP 的头部扩展，HTTP Cookies 就可以解决这个问题。将 Cookies 添加到头部中，创建一个会话让每次请求都能够共享相同的上下文信息，达成相同的状态。

### HTTP 和连接

一个连接是由控制层来控制的，这从根本上不属于 HTTP 的范围。HTTP 并不需要其底层的传输协议是面向连接的，只要它是可靠的，或者不丢失消息的。在互联网中，有两个最常用的传输协议，TCP 是可靠地，而 UDP 不是。因此，HTTP 依赖面向连接的 TCP 进行消息传递，但连接并不是必须的。

HTTP/1.0 为每个请求/响应都打开了一个 TCP 连接，这就导致了 2 个缺点：打开一个 TCP 连接需要多次往返消息传递，因此速度较慢。但是当多个消息周期性发送时，这样就变得更加高效：暖连接比冷连接更高效。

为了减轻这些缺陷，HTTP/1.1 引入了流水线和持久连接的概念。底层的 TCP 连接可以通过 `Connection` 头部来被部分控制。HTTP/2 则发展的更远，通过在一个连接复用消息的方式来让这个连接始终保持为暖连接。

为了更好地适合 HTTP，设计一种更好的传输协议的进程一直在进行。Google 就研发了一种基于 UDP 能够提供更为高效的传输协议 QUIC。

### HTTP 能做什么

多年以来，HTTP 良好的扩展性使得越来越多的 web 功能归其控制，缓存和认证很早就可以由 HTTP 控制了。另一方面，对同源同域的限制到 2010 年才有所改变。

以下是可以被 HTTP 控制的常见特性：

- **缓存**：文档如何缓存能够通过 HTTP 来控制。服务端能够告诉代理和客户端哪些文档需要被缓存。缓存多久。而客户端也能够命令中间的缓存代理来忽略存储的文档。
- **开放同源限制**： 为了防止网络窥听和其他隐私泄露。浏览器强制对 web 网站进行了分割限制。只有来自于**相同来源**的网页才能够获取网站的全部信息。这样的限制有时反而成了负担。HTTP 可以通过修改头部来开放这样的限制，因此 web 文档可以是由不同域下的信息拼接而成的。
- **认证**： 一些网页能够被保护起来，仅让特定的用户进行访问。基本的认证功能可以直接通过 HTTP 提供，使用`Authenticate`相似的头部即可，或使用 HTTP Cookies 来设置指定的会话
- **代理和隧道**： 通常情况下，服务器或客户端是处于内网的，对外网隐藏真正的 IP 地址，因此 HTTP 请求就要通过代理越过这个网络屏障，但并非所有的代理都是基于 HTTP 处理。例如，SOCKS 协议的代理就运作在更底层，一些像 FTP 这样的协议也能够被它处理。
- **会话**: 使用 HTTP Cookies 允许你用一个服务端的状态发起请求，这就创建了会话，虽然基本的 HTTP 是无状态协议。这很有用，不仅是因为这能应用到像购物车这样的电商业务上，更是因为这使得任何网站都能轻松为用户展示定制内容。

### HTTP 流

当客户端想要和服务端进行信息交互时（服务端指的是最终服务器或者一个中间代理），过程表现为以下几步：
- 打开一个 TCP 连接，TCP 连接被用来发送一次或多次请求，以及接收响应消息。客户端可能打开一条新的连接，或者重用一个已经存在的连接，或者也可能开几个新的 TCP 连接连向服务端。
- 发送一个 HTTP 报文。HTTP 报文(HTTP/2之前）是语义可读的，在 HTTP/2 中，这些简单的消息被封装到了帧中，这使得报文不能被直接读取，但是原理仍然是相同的。
```html
GET / HTTP/1.1
Host: developer.mozilla.org
Accept-Language: fr
```
- 读取服务端返回的报文信息
```html
HTTP/1.1 200 OK
Date: Sat, 09 Oct 2010 14:28:02 GMT
Server: Apache
Last-Modified: Tue, 01 Dec 2009 20:18:22 GMT
ETag: "511..."
Accept-Ranges: bytes
Content-Type: text/html

<!DOCTYPE html>....
```
- 关闭连接或者为后续请求重用连接

当 HTTP 流水线启动的时候，后续请求都可以不用等待第一个请求的成功响应就被发送。然而 HTTP 流水线已经被证实很难在现有的网络中实现，因为现有网络有很多老旧的软件与现代版本的软件共存。因此 HTTP 流水线已经被在有多个请求下表现更稳健的 HTTP/2 帧所取代。

## HTTP 报文

HTTP1.1 以及更早的 HTTP 协议报文都是语义可读的。在 HTTP/2 中这些报文被嵌入到了一个新的二进制结构，帧。帧允许实现很多优化。比如报文头部的压缩和复用。即使只有原始 HTTP 报文的一部分以 HTTP/2 发送出来，每条报文的语义依旧不变。客户端会重组原始 HTTP/1.1 请求。因此用 HTTP/1.1 格式来理解 HTTP/2 报文依旧有效。

有两种 HTTP 报文的类型，请求与响应。每种都有特定的格式。

### 请求

```html
GET / HTTP/1.1
Host: developer.mozilla.org
Accept-Language: fr
```

请求由以下元素组成：

- 一个 HTTP 的 method，经常是由一个动词，像`GET`、`POST`或者一个名词像`OPTIONS`，`HEAD`来定义客户端的动作行为。通常客户端的操作都是获取资源，或者发送表单值。虽然在一些情况下也会有其他操作
- 要获取的资源的路径，通常是上下文中就很明显的元素资源的 URL。它没有`protocol`,`domain`或是 TCP 的`port`。
- HTTP 协议版本号
- 为服务端表达其他信息的可选头部 headers
- 对于一些像 POST 这样的方法，报文的 body 就包含了发送的资源，这与响应报文的 body 类似。

### 响应

响应报文包含了以下元素：

- HTTP 协议版本号
- 一个状态码，来告知对应请求的成功或失败，以及失败的原因
- 一个状态信息，这个信息是非权威的状态码描述信息，可以由服务端自己定义。
- HTTP headers，与请求头部类似
- 可选项，比起请求报文，响应报文中更常见地包含获取的资源的 body。