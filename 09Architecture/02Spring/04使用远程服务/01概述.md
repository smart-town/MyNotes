# 概述

我们开发的很多应用就像被遗弃的荒岛，表面上看它们好像能够自给自足，但是实际上，它们可能还需要和其他系统相互合作，这些系统既包括组织的内部也包括组织的外部。

例如采购系统需要和厂商的供应链系统通信，公司的人力资源系统可能需要集成薪酬系统或者薪酬系统需要和打印、邮寄等外部系统进行通信。无论哪种情况，我们的系统都要和其他系统进行交互，远程访问它们的服务。

作为一个 Java 开发者，我们有多种可以使用的远程调用技术，包括：
- 远程方法调用 RMI
- Hessian 和 Burlap
- Spring 基于 HTTP 的远程服务
- 使用 JAX-RPC 和 JAX-WS 的 Web Service

## 概览

**远程调用**是客户端应用和服务端之间的会话，在客户端，它所需要的一些功能并不在该应用的实现范围之内，所以应用要向能够提供这些功能的其他系统寻求帮助。而远程应用通过远程服务暴露这些功能。

假设我们想要将应用 A 的某些功能发布为远程服务并提供给其他应用来使用，或许除了基于浏览器的用户界面，我们还想为 A 应用提供桌面应用或者移动端应用。为了实现此想法，我们要将其基本功能发布为远程服务。

其他应用和 Spitter 之间的会话开始于客户端应用的一个**远程过程调用(Remote Procedure Call, RPC)**。从表面上看，RPC 类似于调用一个本地对象的一个方法，这两者都是同步操作，会阻塞调用代码的执行，直到被调用的过程执行完毕。

它们的差别仅仅是距离上的问题，类似于人和人之间的交流，如果我们在公共场所交谈就是本地，而打电话则相当于 RPC 了。

Spring 支持多种不同的 RPC 模型，包括 RMI、Hessian 和 Burlap 等，这里是概述以及简要的场景：
 RPC 模型 | 适用场景
 :-----: | :-----:
 RMI | 不考虑网络限制时（如防火墙），访问、发布基于 Java 的服务
 Hessian 或 Burlap | 考虑网络限制时，通过 HTTP 访问/发布基于 Java 的服务，Hessian 是二进制协议而 Burlap 是基于 XML 的
 HTTP invoker | 考虑网络限制，并希望使用基于 XML 或者专有的序列化机制实现 Java 的序列化时，访问/发布基于 Spring 的服务
 JAX-RPC 和 JAX-WS | 访问/发布平台独立的，基于 SOAP 的 web 服务

 无论选择哪种的远程调用模型，都会发现 Spring 提供乐风格一致的支持。这意味着一旦理解了如何配置 Spring 来使用其中的一种模型，如果我们决定使用另外一种模型的话，将会拥有非常低的学习曲线

 在所有的模型中，服务都作为 Spring 所管理的 bean 配置到我们的应用中，这是通过一个代理工厂 bean 实现的。这个 bean 能够把远程服务像本地对象一样装配到其他 bean 的属性中。

 客户端向代理发起调用，就像代理提供了这些服务一样。代理代表客户端与远程服务通信，由它负责处理连接的细节并向远程服务发起调用。更重要的是，如果调用远程服务时发生 `java.rmi.RemoteException`异常时，代理会处理此异常并重新抛出非检查型异常。远程异常通常预示着系统发生了无法恢复的问题，如网络或者配置问题。既然客户端通常无法从远程异常中恢复那么重新抛出`RemoteAccessException`就能让客户端来决定是否处理此异常。

 在服务器端，我们可以使用任意一种模型将 Spring 管理的 bean 发布为远程服务。通常是远程导出器(remote exporter) 将 bean 方法发布为远程服务。

 无论我们开发的是使用远程服务的代码还是实现这些服务的代码，或者两者兼而有之，在 Spring 中，使用远程服务纯粹是一个配置问题。我们不需要编写任何 java 代码就可以支持远程调用。我们的服务 bean 也不需要关心它们是否参与了一个 RPC 。当然，任何传递给远程调用的 bean 或者从远程调用返回的 bean 都需要实现 Serializable 接口。