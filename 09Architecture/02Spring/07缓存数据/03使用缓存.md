# 使用缓存

为方法添加注解以支持缓存。

Spring 的缓存抽象很大程度上是围绕切面创建的，在 Spring 中启用缓存时，会创建一个切面，它触发一个或者更多个 Spring 缓存注解。下面的所有注解都能用在方法或者类上，当将其放到单个方法上时，注解所描述的缓存行为只会运用到这个方法上。如果放到类级别则会缓存行为就会用到这个类的所有方法上。

注解 | 描述
------ | -------
@Cacheable | 表明 Spring 在调用方法之前，首先应该在缓存中查找方法的返回值。如果这个值能够找到，就会返回缓存的值。否则该方法就会被调用，返回值放到缓存中
@CachePut | 表明 Spring 应该将该方法的返回值放到缓存中，在该方法被调用前并不会检查缓存，方法始终会被调用
@CacheEvict | 表明应该在缓存中清除一个或者多个条目
@Caching | 这是一个分组的注解，能够同时应用其他其他的缓存注解

## 填充缓存

可以看到`@Cacheable`和`@CachePut`都可以填充缓存，但是工作方式略有区别。其有一些属性是共有的：
- value:(String[]) 要使用的缓存名称
- condition:(String) SpEL 表达式，如果得到的值是 false 的话，不会将缓存应用到方法调用上
- key(String): SpEL 表达式用来计算自定义的缓存 key
- unless : SpEL 表达式，如果得到的值是 true 的话，返回值不会放到缓存中

```java
@Cacheable("spittleCache")
public Spittle findOne(long id){
    try {
        return jdbcTemplate.queryForObject(QUERY,new SpittleMapper(), id) ;
    } catch(Exception e){}
}
```

当 findOne 被调用时，缓存切面会拦截调用并在缓存之前查找以前以名为`spittleCache`存储的返回值，缓存的`key`是传递到 findOne() 方法中的参数，如果按照这个参数能够找到值得话就会返回找到的值，方法不会被调用。否则就会继续调用这个方法并将返回值放入到缓存中。

当为**接口**方法添加注解后，`@Cacheable`注解会被所有该接口的实现继承。这些实现类都会应用相同的缓存规则。

### 将值放到缓存中

`@Cacheable`会条件性地触发对方法的调用。这取决于缓存中是不是已经有了所需要的值。对于所注解的方法。`@CachePut`采用了更为直接的流程。带有`@CachePut`的方法始终都会被调用，而且他的值也会被放到缓存中，这提供了一种很便利的机制，能够让我们在请求之前预先加载缓存。如当新增一条记录后很可能马上请求该记录，此时就可以使用该注解直接缓存。
```java
@CachePut("spittleCache")
Spittle save(Spittle spittle);
```
