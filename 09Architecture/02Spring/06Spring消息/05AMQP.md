# 高级消息队列协议

多年来，JMD 一直是 Java 应用中主流的消息解决方案，但是对于 Java 和 Spring 开发者而言，JMS 并不是唯一的消息可选方案。**高级消息队列协议** Advanced Message Queuing Protocol 近年来得到了广泛的关注。

AMQP 具备多项 JMS 所不具备的优势。JMS 定义的是 API 规范，JMS 的 API 规范协议能够确保所有的实现都能通过通用的 API 来使用，但是并不能保证某个 JMS 实现所发送的消息能够被另外不同的 JMS 实现所使用。而 AMQP 定义了线路层协议，其规范了消息的格式，消息在生产者和消费者传送的时候回遵循这个格式。这样 AMQP 在互相协作时优于 JMS——不仅能够夸不同的 AMQP 实现，还能跨语言和平台。

相比 JMS ，AMQP 另外一个明显的优势是它具有更灵活和透明的消息模型。使用 JMS 的话，只有两种消息模型可供选择：点对点 和 发布订阅。这两种模型在 AMQP 中都是可以实现的。但是 AMQP 还能够让我们以其他的多种方式来发送消息。这是通过将消息的生产者和存放消息的**队列**解耦实现的。

## 简介

JMS 中有三个主要参与者：消息的生产者、消费者、传递消息的通道（队列或主题）。在 JMS 中，通道有助于解耦消息的生产者和消费者，但是这两者仍然会与通道耦合，生产者将消息发布到一个特定的主题或者队列上，消费者从特定的队列或者主题上接收这些消息，通道具有双重责任，也就是传递数据以及确定这些消息应该发送到什么地方。

与之不同的是，AMQP 的生产者并不会直接将消息发布到队列中，AMQP 的生产者以及传递消息的队列之间引入了一种间接机制：`Exchange`。消息的生产者将信息发布到一个 Exchange，Exchange 会绑定到一个或者多个队列上，它负责将信息路由到队列上，信息的消费者会从队列中提取数据并并进行处理。

Exchange 并不是简单地将消息传递到队列中，并不仅仅是一种穿透机制。(pass through)。AMQP 定义了四种不同类型的 Exchange，每一种都有不同的路由算法，这些算法决定了是否有要将信息放到队列中，根据 Exchange 的不同，它可能会使用消息的 routing key 和`/`或者参数，并将其与 Exchange 和队列之间的 binding 的 routing key 和参数进行比较(routing key 可以大致理解为 Email 的收件人地址，指定了预期的接受者)。如果对比满足相应的算法，那么消息将会被路由到队列中。否则的话不会路由到队列中。

四种 AMQP Exchange:
- `Direct`: 如果消息的routing key和 binding 的 routing key 直接匹配的话，消息将会路由到该队列上
- `Topic`: 如果两者符合通配符匹配的话，消息将路由到该队列上
- `Headers`: 如果消息参数表中的头信息和binding参数表中相匹配，消息路由到队列上
- `Fanout`: 无论消息的routing key和参数表的头信息/值是什么，消息都会路由到**所有**队列上

简单来讲，生产者将信息发送给 Exchange 并带有一个 routing key，消费者从队列中获得消息

