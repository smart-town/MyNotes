# Spring 消息

使用 RMI、Hessian、Burlap、HTTP invoker 在应用程序之间进行通信时，所有的这些通信机制都是同步的，客户端应用程序直接和远程服务器交互，并且等到远程过程调用完成后才继续执行。

同步通信有其自己的适用场景，不过对于开发者而言，这种通信方式并不是应用程序之间进行交互的唯一方式。**异步消息**是一个应用程序向另一个应用程序间接发送消息的一种方式，这种方式无需等待对方的响应。相对于同步消息，异步消息具有多个优点。

借助 Spring，我们有多个实现异步消息的可选方案。如 JMS、AMQP

## 简介

与 REST 接口和远程调用接口相似，异步消息也用于应用程序之间的通信。但是在系统之间传递信息的方式上，它与其他机制有所不同。像 RMI 和 Hessian/Burlap 这样的远程调用机制是同步的，当客户端调用远程方法的时候，客户端必须等到远程方法完成后才能继续执行。即使远程方法不向客户端返回任何信息，客户端也要被阻塞直到服务完成。

消息则是异步通信的，客户端不需要等待服务处理消息，甚至不需要等待消息投递完成。客户端发送消息，然后继续执行，这是因为客户端假定服务最终可以收到并且处理这条消息。

### 发送消息

**间接性**是异步消息的关键所在，当一个应用程序向另一个应用程序发送消息时，两个应用之间没有直接的联系。相反的是，发送方的应用程序会将消息交给一个服务。由服务确保将消息投递给接收方的应用程序。

在异步消息中两个主要的概念：**消息代理**和**目的地**。当一个应用发送消息时，会将消息交给一个消息代理。消息代理实际上类似于邮局，消息代理可以确保消息被投递到指定的目的地，同时解放发送者，使其能够继续进行其他的业务。

当我们投递信件时，最重要的是要写上地址，这样邮局就可以知道这封信应该被投递到哪里。与此类似，每一条异步消息都带有一个目的地，目的地就好像一个邮箱，可以将消息放入到这个邮箱，直到有人取走。

不过并不像信件地址那样必须标识特定的收件人或者街道地址，消息中的目的地相对来说并不那么具体。目的地只关注消息应该从哪里获得——而不关心由谁取走消息。

尽管不同的消息系统会提供不同的消息路由模式，但是有两种通用的目的地：**队列**和**主题**。每种类型都与特定的消息模型关联，分别是点对点模型和发布/订阅模型。

#### 点对点消息模型

在点对点模型中，每一条消息都有一个发送者和一个接收者。当消息代理得到消息时，它将消息放入到一个队列中。当接收者请求队列中的下一条消息时，消息会从队列中取出，并投递给接收者。因为消息投递后会从队列中删除，这样就可以保证消息只能投递给一个接收者。

尽管消息队列中的每一条消息只能被投递给一个接收者，但是并不意味着只能使用一个接收者从队列中获取消息。事实上，通常可以使用几个接收者来处理队列中的消息。不过每个接收者都会处理自己所接收到的消息。

在点对点的消息中，如果有多个接收者在监听队列。我们也无法知道某条特定的消息会由哪一个接收者处理。这种不确定性实际上有很多好处，因为我们只需要简单地为队列添加新的监听器就能够提高应用的消息处理能力。

#### 发布-订阅消息模型

