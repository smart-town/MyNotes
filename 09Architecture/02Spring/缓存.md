缓存的 key ，默认的情况下是基于方法的参数。对于`save(Spitter spitter)`方法来讲，它的默认 key 将是 Spitter，这明显是不合常理的。显然在这种场景下，默认`key`并不是我们想要的。

## 自定义缓存 key

`@Cacheable`和`@CachePut`都有一个名为 key 属性，这个属性能够替换默认的 key。它是通过一个 SpEL 表达式计算的。任何 SpEL 表达式都是可行的，但是更场景的场景是所定义的表达式和存储在缓存中的值有关，据此计算得到 key。

具体到这个场景，我们将 key 设置为所保存的 Spitter 的 ID，以参数形式传递给 save() 的 Spitter 还没有保存，因此并没有 ID。我们只能通过 save 返回的 Spitter 得到 ID 属性。

在为缓存编写 SpEL 表达式时，Spring 暴露了一些很有用的元数据。

表达式 | 描述
------ | ------
#root.args | 传递给缓存方法的参数，形式为数组
#rootcaches | 该方法执行时所对应的缓存，形式为数组
#root.target | 目标对象
#root.targetClass | 目标对象的类
#root.method | 缓存方法
#root.methodName | 缓存方法的名称
#result | 方法调用的返回值（不能用在 @Cacheable 主街上）
#Argument | 任意的方法参数名，如#argName或参数索引 #a0

对于 save() 方法来说，我们需要的键是所返回的 Spitter 对象的 ID 属性，表达式`#result`能够得到返回的`Spitter`对象，借助这个对象，我们可以通过将 key 属性设置为 `#result.id`来引用 id 属性
```java
@CachePut(value="spittleCache", key="#result.id")
Spittle save(Spittle spittle)
```

## 条件化缓存

通过为方法添加 Spring 的缓存注解，Spring 就会围绕着这个方法创建一个缓存切面。但是，有些场景下我们可能希望将缓存功能关闭。

`@Cacheable`和`@CachePut`提供了两个属性用以实现条件化缓存：`unless`和`condition`，这两个属性都接受一个 SpEL 表达式，如果`unless`属性的 SpEL 表达式计算结果为 true，那么缓存方法返回的数据就不会放到缓存中，与之类似，`condition`恰好相反。

表面上看两者似乎做的是同一件事情，但是，有一些细微的差别。`unless`属性只能阻止将对象放入缓存，但是这个方法调用的时候，依然会去缓存查找，如果找到了匹配的值就会返回找到的值。与之不同，如果`condition`的计算结果为 false，那么在这个方法调用的过程中，缓存是被禁用的，也就是说不会去缓存进行查找，同时返回值也不会放进缓存。

```java
@Cacheable(value="spittleCache" unless="#result.message.contains('NoCache')")
Spittle findOne(long id);
```
这里对于 message 属性中包含`NoCache`的 Spittle 对象，我们不想对其进行缓存。为 unless 设置的 SpEL 表达式会检查返回的 Spittle 对象，如果其 message 属性包含"NoCache"内容，那么这个表达式的计算值为 true，这个 Spittle 对象不会被放到缓存中。否则会被缓存。

属性 unless 能够阻止将值写入到缓存中，但是有时候我们会希望将缓存全部禁用。也就是说，在一定条件下，我们希望既不将值添加到缓存中，也不希望从缓存中获取数据。

例如对于 ID 小于 10 的 Spittle 对象，我们不希望对其缓存。这些 Spittle 是用来调试的测试项目，对其缓存没有太大意义：
```java
@Cacheable(value="spittleCache" condition="#result.message.contains("NoCache")")
Spittle findOne(long id)
```

## 移除缓存条目

`@CacheEvict`，带有该注解的方法被调用的话，那么会有一个或者更多的条目会在缓存中移除。
```java
@CacheEvict("spittleCache")
void remove(long id) ;
```
注意 value 是`String[]`类型。