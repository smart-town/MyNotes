# 对象的扩展

## 1. 属性的简洁表示

ES6 允许大括号中直接写入变量和函数，作为对象的属性和方法。如：`const foo='foo';const baz={foo};`此时，属性名就是变量名，属性值就是变量值。

## 2. 属性名表达式

JavaScript 定义对象的属性，有两种方法，即通过`.`或`[]`运算符。在使用字面量定义对象（使用大括号）时，在 ES5 中只能使用标识符（字符串）定义属性，ES6 允许字面量定义对象时，用表达式作为对象的属性名，即把表达式放在`[]`中。

**注意**：
1. 属性名表达式和简洁表示法不能同时使用。
2. 属性名表达式如果是一个对象，默认情况下会自动将对象转换为字符串：`[object Object]`。

## 3. 方法的 name 属性

函数的`name`属性，返回函数名，对象方法也是函数，因此也有`name`属性。但是如果对象的方法上使用了取值函数或者存值函数，则 name 属性不是在该方法上而是在该方法属性描述对象的`get`和`set`属性上。

有两种特殊情况，`bind`方法创建的函数以及`Function`构造函数创建的函数，`name`属性会附加`bound`或`anoymous`。如果对象的方法是一个`Symbol`值则`name`返回的是其描述。

## 4. 属性的可枚举性和遍历

#### 可枚举性

属性描述对象中的`emnumerable`控制属性的**可枚举性**。如果可枚举性为 false，则当前有四个操作默认忽略该属性：
- `for...in`循环，只遍历对象自身和继承的可枚举性属性
- `Object.keys()`返回对象自身所有可枚举的属性键名
- `JSON.stringify()`只串行化对象自身可枚举属性
- `Object.assign()` 忽略`enumerable`为`false`属性。只拷贝对象自身可枚举的属性。

这四个操作中前三个是 ES5 中就有的，最后一个是 ES6 新增的方法。其中`for...in`会返回继承的属性，其他三个都会忽略继承的属性，只处理对象自身的属性。**实际上**，引入**可枚举性**这个概念的最初目的，就是为了让某些属性可以让某些属性可以规避掉`for...in`操作，不然所有内部属性和方法都会被遍历到。如，对象原型的`toString()`方法，以及数组的`length`，就通过可枚举性，从而避免被`for...in`遍历到。

