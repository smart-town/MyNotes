# 浏览器环境概述

JavaScript 是浏览器的内置脚本，也就是说，浏览器内置了 JavaScript 引擎，并且提供各种接口，让 JavaScript 脚本可以控制浏览器的各种功能，一旦网页内嵌了 JavaScript 脚本，浏览器加载网页，就会去执行脚本，从而达到操作浏览器的目的，实现网页的各种动态效果。

## 1. 代码嵌入网页的方法

### 1.1 script 元素嵌入代码

`<script>`元素内部可以直接写 js 代码。`<script>`标签有一个`type`属性，用来指定脚本类型。对 JavaScript 脚本来说，`type`可以设置为两种值
- `text/javascript`: 这是默认值，也是历史上一贯设定的值。如果省略`type`属性，**默认**就是这个值。
- `application/javascript`: 对于较新的浏览器，建议设置为这个值

由于`<script>`标签默认是 JavaScript 代码，所以嵌入 JavaScript 脚本时，`type`属性可以省略。如果`type`中的值，浏览器不认识，那么它不会执行其中的代码，利用这一点，可以在`<script>`标签中嵌入任意的文本内容，只要加上一个浏览器不认识的`type`属性即可。如`<script type="mydata">console.log("Hello")</script>`

### 1.2 script 元素加载外部脚本

`<script>`标签也可以指定加载外部的脚本文件。如果脚本文件使用了非英语字符，还应注明字符的编码：`<script charset="utf-8" src="https://example.com/test.js"></script>`

**注意**加载的脚本必须是纯的 JavaScript 代码，且加载外部脚本和直接嵌入代码块，这两种方法不能混用。

为了防止攻击者篡改外部脚本，`script`标签允许设置一个`integrity`属性写入该脚本的 Hash 签名，用来验证脚本的一致性。

### 1.3 事件属性

网页元素的事件属性，如`onclick`和`onmouseover`，可以直接写入 javascript 代码，指定事件发生时，就会直接调用这些代码。

### 1.4 URL 协议

URL 支持`javascript:`协议，即在 URL 位置写入代码，使用这个 URL 时就会执行 js 代码：`<a href="javascript:console.log('left')">left</a>`,浏览器的地址栏也可以支持`javascript`协议，如果 js 代码返回一个字符串，浏览器就会新建一个文档展示这个字符串的内容，原有文档内容消失。

`javascript:`协议最常见的用途就是书签脚本，由于浏览器的书签保存的是一个网址，所以`javascript:`也可以保存在其中，用户选择这个书签的时候就会在当前页面执行这个脚本，为了防止书签替换掉当前文档，可以在脚本前加上`void`。

## 2.script 元素

### 2.1 工作原理

浏览器加载 javascript 脚本，主要通过`script`元素完成，正常的网页加载流程：
1. 浏览器一边下载 HTML 文档一边开始解析，也就是说不等到下载完就开始解析
2. 解析过程中，浏览器发现`<script>`元素，就暂停解析，把网页渲染的控制权转交给 js 引擎
3. 如果`<script>`元素引用了外部脚本，就下载该脚本再执行，否则就直接执行代码
4. js 引擎执行完毕，控制权交还渲染引擎，恢复往下解析 HTML 网页

加载外部脚本时，浏览器会暂停页面渲染，等待脚本下载并执行完毕后，再继续渲染，原因是 js 可以修改 DOM，所以必须把控制权转交给它，否则会导致复杂的线程竞争问题。

如果外部脚本加载时间很长（一直无法完成下载），那么浏览器就会一直等待脚本下载完成，造成网页长时间无法响应，浏览器就会呈现“假死”状态。这被称为“阻塞效应“

为了避免这种情况，最好的做法是将`<script>`标签都放在页面底部，而不是头部，这样即使遇到脚本失去响应，网页主体的渲染也已经完成了。用户至少可以看到内容，而不是面对空白页面。如果某个脚本代码非常重要，必须放在页面头部，则最好将代码直接写入页面而不是连接外部脚本文件，这样能缩短加载时间。

脚本文件都放在网页底部加载，还有一个好处，因为 DOM 结构生成之前就调用 DOM 节点，js 会报错，如果脚本在网页尾部加载，就不存在这个问题。因为这时候 DOM 肯定已经生成了。

如果有多个`script`标签，如
```html
<script src="a.js"></script>
<script src="b.js"></script>
```
此时浏览器会同时并行下载`a.js`和`b.js`，但是执行时会保证先执行`a.js`，然后再执行`b.js`，即使后者先现在完成。这就意味着，**脚本的执行顺序由它们在页面中出现的顺序决定**，这是为了保证脚本之间的依赖关系不受到破坏，当然，加载这两个脚本都会产生”阻塞效应“，必须等到它们都加载完成，浏览器才会继续页面渲染。

解析和执行 CSS，也会产生阻塞。Firefox 会等到脚本前面所有的样式表都下载且解析完再执行脚本，webkit 则是一旦发现脚本引用了样式，就会暂停脚本，等到样式表下载并解析完成，再恢复执行。

此外，**对于来自于同一个域名的资源文件**，比如脚本文件、样式表文件、图片文件等。浏览器一般有限制，同时最多下载 6 ～ 20 个资源，即最多同时打开的 TCP 有限制，这是为了防止对服务器造成太大压力，如果是来自不同域名的资源，就没有这个限制，所以通常把静态文件放在不同的域名之下，以加快下载速度。

### 2.2 defer 属性

为了解决脚本下载阻塞网页渲染的问题，一个方法是对`<script>`元素添加`defer`属性，它的作用是延迟脚本的执行，等到 DOM 加载生成后，再执行脚本。

即，浏览器开始解析网页，解析过程中遇到带有`defer`的`script`，浏览器继续向下解析网页，同时并行下载`script`元素加载的外部脚本，解析完网页后此时再执行已经下载完的脚本。

有了`defer`属性，浏览器下载外部脚本的时候，不会阻止页面渲染，下载的脚本文件在`DOMContentLoaded`事件触发前执行。而且可以保证执行顺序就是它们出现的顺序。

对于内置而不是加载外部脚本的`script`标签，以及动态生成的`script`标签，`defer`属性**不起作用**。

### 2.3 async 属性

解决阻塞效应的另外一种方法是`script`元素的`async`属性

其作用是，使用另一个进程下载脚本，下载时不会阻塞渲染。

即，浏览器开始解析网页，解析过程中发现带有`async`的`script`标签，浏览器继续向下解析 HTML 网页，同时并行下载`script`标签中的外部脚本。脚本下载完成浏览器暂停解析 HTML 网页，开始执行下载的脚本。脚本执行完毕后，浏览器恢复解析网页。

`async`可以保证脚本下载的同时，浏览器继续渲染。需要**注意**的是，一旦采用了这个属性，就**不能保证脚本的执行顺序**，哪个脚本先下载完成就先执行哪个脚本。

一般来说，如果脚本之间没有依赖关系就使用`async`，否则使用`defer`。如果同时有这两个属性，则`defer`不起作用。

### 2.4 动态加载

`<script>`元素还可以动态生成，生成后再插入到页面。从而实现脚本的动态加载。

## 3.加载使用的协议

如果不指定协议浏览器默认使用 HTTP 协议下载：`<script src="example.js"></script>`

如果要采用`https`则需要指明`https://example.js`

有时候希望根据页面本身的协议决定加载协议：`<script src="//example.js"></script>`

