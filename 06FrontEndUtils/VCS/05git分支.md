# Git 分支

几乎所有的版本控制系统都以某种形式支持分支，使用分支意味着可以将你的工作从开发主线上分离开来，以免影响开发主线。在很多版本控制系统中，这是一个略微低效的过程——常常需要完全创建一个源代码目录副本，对于大型项目来说这种操作十分耗费时间。

而 Git 处理分支的方式可谓是难以置信的轻量。几乎能够在瞬间完成。

## 分支简介

需要理解 git 如何保存数据，git 保存的不是文件的变化或差异，而是一系列不同时刻的文件快照。在进行提交操作时，git 会保存一个提交对象，该提交对象包含一个指向暂存内容的快照指针。该提交对象还包含了作者的信息等。

首次提交产生的提交对象没有父对象。普通提交操作产生的提交对象有有一个父对象，而由多个分支合并产生的提交对象有多个父对象。

理解，假设有一个工作目录，其中包含了三个要被暂存和提交的文件。暂存操作会为每一个文件计算校验和(SHA-1)，然后将当前版本的文件快照保存到 Git 仓库中（Git 使用 blob 对象保存它们），最终将校验和加入到暂存区域等待提交。当使用`git commit`进行提交时，Git 会先计算每一个子目录的校验和，然后在 Git 仓库中这些校验和保存为树对象，随后，Git 创建一个提交对象，该对象包含以上信息外，还会包含指向这个树对象的指针。如此一来，Git 就可以在需要的时候重现此次保存的快照。

现在，Git 仓库中有 5 个对象：三个 blob、一个树对象（记录着目录索引和blob对象索引）、一个提交对象。

Git 的分支，其本质上仅仅是指向提交对象的可变指针。Git 默认分支名称为 master，在多次操作之后，其实已经有一个指向最后那个提交对象的`master`分支。它会在每次提交操作中自动向前移动。 master 并不是特殊分支，和其他分支完全一样。

## 分支创建

它只是创建了一个可以移动的新指针。`git branch testing`。就创建了一个新分支`testing`

而，Git 又如何知道当前在哪个分支上呢？它有一个名为`HEAD`的指针，指向当前所在的本地分支上。可以使用`git log --decorate`查看各个分支当前所指对象。

## 分支切换

`git checkout testing`。

如果此时修改文件并提交，再次切换回`git checkout master`，此时 testing 分支已经前进了，而 master 分支并没有前进，该命令会做两件事：一是使得 HEAD 指向 master 分支，二是将工作目录恢复为 master 分支所指向的快照内容。也就是说，现在修改的话，项目将始于一个较旧的版本。本质上来说就是忽略`testing`所做更改以便向另一个方向进行开发。

### 分支会改变工作目录中的文件

在切换分支时一定要保证工作目录中的文件会被改变，如果是切换到旧分支，那么目录会恢复为该分支最后一次提交时的样子。如果 git 不能干净完成这个任务，它将禁止切换。

此时可以在 master 上继续修改并提交，这样一来，项目的提交历史就会产生分叉。你可以在不同的分支上不断来回切换和工作并在时机成熟时将它们合并起来。可以简单使用`git log --oneline --decorate --graph --all`查看分叉情况

由于 Git 分支事实上仅是包含所指对象校验和的文件，所以他的创建和销毁都异常高效。创建一个新分支就相当于写入了 41 个字节。

## 分支新建和合并

看一个简单的例子，假设：
1. 开发某个网站
2. 为实现某个需求创建一个新分支
3. 在这个分支上开展工作。

此时遇到一个问题需要修复，可以这样处理：
1. 切换到线上分支
2. 为紧急任务新建一个分支并在其中修复它
3. 测试通过后，切换回线上分支然后合并这个修补分支，最后将改动推送到线上分支
4. 切换回最初分支继续工作

### 新建分支

假设问题为 #53，新建一个分支并同时切换到那个分支：`git checkout -b iss53`

你继续在 iss53 上工作，并且在此过程中，iss53 不断地在向前推进，因为已经检出到该分支，即 HEAD 指针指向了 iss53 分支

现在假设又有一个紧急问题等待修复，有了 Git 帮助，不必将这个紧急问题修复和 iss53 修改混在一起，也不需要花大力气还原关于 #53 的修改，需要做的仅仅是切换回 master 分支。但是在这样做之前要确保工作目录和暂存区中已经没有被提交的修改，它可能会和你即将检出的分支产生冲突从而阻止 Git 切换到该分支。【保存进度】

假设已经将所有修改提交了，此时就可以切换回 master ，并专心修复新问题了。开始修复：`git checkout -b hotfix`，测试完成后，可以使用`git merge`将其合并到`master`分支上并部署到线上：`git checkout master; git merge hotfix`。

由于当前 master 分支指向的提交是你当前提交的直接上游（有关 hotfix）的提交，所以 Git 只是简单地将指针向前移动。换句话说，当你试图合并两个分支时，如果顺着一个分支能够到达另一个分支，那么 Git 在合并两者的时候只会简单地将指针向前推进。因为这种情况下的合并操作没有需要解决的分歧，这就叫做“快进” fast-forward

该问题解决之后，你准备回到之前被打断的工作中，然而你应该首先删除`hotfix`分支因为已经不再需要它了。`git branch -d hotfix`。

切换回分支继续工作：`git checkout iss53`。你在 hotfix 上所做的更改并没有包括到`iss53`中，如果需要拉取`hotfix`所做更改，可以`git merge master`将 master 合并到 iss53 中，或者可以等到 iss53 完成后，将其合并到 master 分支。

### 分支的合并

假设已经修正了 iss53，并打算将其合并到 master，这和之前的操作一样：
```shell
git checkout master

git merge iss53
```
这和之前的 hotfix 合并不太一样。这种情况下，你的开发历史是从一个更早的地方分叉开来的 diverged，因为，master 分支所在提交并不是 iss53 所在提交的直接祖先，此时 Git 不得不做一些额外的工作，出现这种情况的时候，Git 会使用两个分支的末端所指的快照以及这两个 分支的工作祖先，做一个简单的三方合并。

和之前将指针向前推进不同的是，Git 将此次三方合并的结果做了一个新的快照并且自动创建一个新的提交指向他。这个被称作一次**合并提交**，它的特别之处在于他有不止一个父提交。。

需要知道的是，Git 会自行决定选择哪个提交作为最优的共同祖先并以此作为合并基础。这和其他的版本控制系统不同，用户需要自行决定最佳合并基础。此时既然已经合并了修改，就删除 iss53 分支即可。

### 遇到冲突时的分支合并

有时候合并操作并不会很顺利，如果在两个不同的分支中，对同一个文件的不同部分进行了不同修改，Git 就没办法干净合并它们。此时会产生冲突。

Git 此时会做了合并，但是没有自动地创建一个新的合并提交，会暂停下来等待你解决冲突。可以在合并冲突后的任意时刻使用`git status`查看那些因为包含合并冲突而处于未合并状态的文件(unmerged)。

任何因为包含合并冲突而有待解决的文件都会以未合并状态标识出来。Git 会加入标准的冲突解决标记。上部分是`HEAD`所指向的分支，下部分是要合并进来的分支。

冲突解决完毕之后，可以使用`git add`将其标记为冲突已经解决。一旦暂存原本有冲突的文件，git 就会将它们标记为冲突已解决。

【gitmergetool】


## 分支管理

`git branch`不加参数则可以得到当前所有分支列表。

`git branch -v`可以查看每个分支最后一次提交

`--merged`和`--no-merged`可以过滤列表中已经合并或者尚未合并到当前分支的分支。如果要查看哪些分支已经合并到当前分支：`git branch --merged`。在该列表中，没有`*`的分支通常可以使用`git branch -d`删除掉，因为已经将其合并到了另一个分支，所以删除并不会丢失任何工作。

而`git branch --no-merged`查看所有未合并工作的分支，此时如果使用删除命令会失败。可以`-D`强制删除。


