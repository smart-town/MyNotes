# manifest

在使用 webpack 构建的典型应用程序或站点中，有三种主要的代码类型：

1. 你或你的团队编写的代码
2. 你的源码依赖的任何第三方的library或vendor代码
3. webpack的runtime和manifest管理所有模块的交互

## Runtime

主要是指：在浏览器运行期间，webpack用来连接模块化的应用程序的所有代码。runtime包含：在模块交互时，连接模块所需的加载和解析逻辑。包括浏览器中的已经加载模块的连接，以及懒加载模块的执行逻辑。

## Manifest

那么一旦你的应用程序中，形如`index.html`文件、一些bundle和各种资源加载到浏览器中，会发生什么？你精心安排的`/src`目录的文件结构已经不复存在，所以webpack如何管理模块之间的交互呢？这就是`manifest`数据的由来。。

当编译器开始执行、解析和映射应用程序时，它会保留所有模块的详细要点。这个数据集合称为"Manifest"，当完成打包并发送到浏览器时，会在运行时通过Manifest来解析和加载模块。无论你选择哪种模块语法，那些`import`和`require`语句现在都已经转换为`__webpack__require__`方法，此方法指向模块标识符(module identifier)。通过使用`manifest`中的数据，runtime能够查询模块标识符，检索出背后对应的模块。

## 问题

所以，此时已经对webpack的幕后工作已经有了一些了解，可是有什么用呢？

runtime做自己该做的，使用manifest来执行其操作，然后，一旦你的应用程序加载到浏览器中，所有的内容都会展现出魔幻版运行。然而，如果你决定通过使用浏览器缓存来改善项目的性能，理解这一过程变得尤为重要。

通过使用bundle计算出内容散列作为文件名称，这样在内容或文件修改的时候，浏览器中将通过新的内容散列指向新的文件，从而使缓存失效。一旦你开始这样做，会注意到一些有趣的行为，即使表面上某些内容没有改变，计算出的哈希值还是会变，这是因为runtime和manifest的注入在每次构建时都会发生变化。

