# let 和 const

1. let 命令
2. 块级作用域
3. const 命令
4. 顶层对象属性
5. globalThis 对象

## 1. let 命令

`let`声明的变量仅在它所在的代码块内有效。

**特别的**，`for`循环中，设置循环变量的那一部分是一个父级作用域，而循环体内部是一个单独的子作用域。
```js
for(let i=0; i<3; i++){
	let i = 'abc';
	console.log(i);
}
```
以上代码输出 3 次`abc`，表明函数内部的变量`i`和循环变量`i`不在同一个作用域，有各自单独的作用域。


**不存在变量提升**，`var`会存在变量提升的现象，即变量可以在声明之前使用，值为`undefined`，为了纠正这种现象，`let`改变了语法行为，它所声明的变量一定要在声明后使用，否则会报错。

**不允许重复声明**

### 暂时性死区

只要块级作用域内存在`let`命令，它所声明的变量就“绑定”这个区域，不再受外部的影响。ES6 明确规定，如果区块中存在`let`和`const`命令，这个区块对这些命令声明的变量，从一开始就形成封闭作用域，凡是在声明之前就使用这些变量就会报错。暂时性死区意味着，`typeof`不再是百分之百的安全操作。如：
```js
typeof x;//ReferenceError
let x;
```
暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才能获取和使用该变量。

## 2. 块级作用域

ES5 只有全局作用域和函数作用域，没有块级作用域，带来很多不合理的场景。如内层变量可能覆盖外层变量，用来计数的循环变量会泄露为全局变量。

ES6 中`let`实际为 JavaScript 新增了块级作用域。ES6 允许块级作用域的任意嵌套。内层作用域可以定义外层作用域的同名变量。

块级作用域的出现，实际上使得获得广泛应用的 IIFE 不再必要了。
```js
//IIFE 写法
(function(){
	var tmp = ...;
	...;
})();

//块级作用域
{
	let tmp = ...;
	...;
}
```

### 块级作用域和函数声明

函数能不能在块级作用域中声明呢？ES5 规定，函数只能在顶层作用域和函数作用域中声明，不能在块级作用域中声明。如：
```js
if(true){
	function f(){}
)
//在 ES5 中是非法的
```
但是浏览器并没有遵循这个规定，为了兼容以前的旧代码，还是支持在块级作用域中声明函数。因此上面的代码是可以执行的。

ES6 引入了块级作用域，明确规定可以在块级作用域中声明函数，在块级作用域中，函数声明语句类似`let`，在块级作用域之外不可引用。
```js
function f(){console.log("outside");}
(function(){
	if(false){
		function f(){console.log("inside");
	}
	f();
})();
```
在 ES5 中，上述代码会输出`inside`，因为在`if`中的声明语句会提升到函数头部。而在 ES6 中就完全不一样了，理论上会得到`outside`，因为块级作用域内声明的函数类似`let`，对作用域之外没有影响。但是如果真的在浏览器中运行，会发现上面代码会报错，为什么呢？

原因在于，如果改变了块级作用域内声明的函数处理规则，显然会对老代码产生很大影响，因此为了减轻因此产生的不兼容问题，ES6 规定浏览器实现可以不遵循上面的规定，有自己的行为方式。
- 允许在块级作用域内声明函数
- 函数声明类似`var`，即会提升到全局作用域或函数作用域头部
- 同时，函数声明还会提升到所在的块级作用域头部

需要注意上面的规则只是对 ES6 浏览器实现有效，其他环境不需要遵守。

考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数，如果确实需要，也应该写成函数表达式而不是函数声明语句。

**注意**，ES6的块级作用域必须有大括号，如果没有大括号，js 引擎认为不存在块级作用域，所以`if(true)let x = 12`是错误的。

