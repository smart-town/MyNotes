# 函数

## 基本

函数的声明：三种方式

### 第一等公民
js 将函数看作一种值，与其他值如数字、字符串地位相同。凡是可以使用值的地方就可以使用函数。函数只是一个可以执行的值除此之外并无特殊，由于函数与其他数据类型地位平等， 又称为**第一等公民**
### 函数名提升
js 引擎将函数名视同变量名，所以采用`function`声明函数时，整个函数会像变量声明一样，被提升到代码头部。

## 函数的属性和方法

### name 属性

`name`属性返回函数名称。该属性的一个用途就是**获取参数函数的名字**

### length 属性

函数`length`属性返回函数预期传入的参数个数。

### toString()

`toString()`方法返回一个字符串，内容是函数的源码。函数内部的注释也可以返回。

## 函数作用域

### 定义

作用域 scope 指的是变量存在的范围。在 ES5 规范中，js 只有两种作用：一种是全局作用域，变量在整个程序中一直存在，所有地方都可以存取。另一种是函数作用域，变量只在函数内部存在。ES6 新增块级作用域。

注意对于`var`变量来说，局部变量只能在函数内部声明，其他区块中声明一律是全局变量。
```js
if(true){
    var x = 5;
}
console.log(x)//5
```

### 函数内的变量提升

### 函数本身的作用域

函数本身也是一个值，具有自己的作用域。它的作用域和变量一样，就是其声明时所在的作用域，与其运行时所在作用域无关。
```js
var a  = 1;
function x(){
    console.log(a);
}
function f(){
    var a = 2;
    x();
}
f();//1
```
上面代码中，函数 x 是在函数 f 外部声明的，所以它的作用域绑定外部，内部变量不会到 f 体内取值。所以输出 1.

即，函数执行时所在的作用域是定义时的作用域。

同样地，函数体内部声明的函数，作用域绑定函数体内部。正是这种机制，形成了闭包

## 参数

参数可以省略。传递方式，原始类型值则传值传递。但是如果参数为复合类型(数组、对象、其他函数)，则是**传址方式**

### arguments 对象

## 函数闭包

闭包`closure`。两种作用域下，函数内部可以访问全局变量，而外部不可以访问函数内部声明的变量。

如果出于种种原因，需要得到函数内的局部变量。正常情况下，是得不到的，只有通过变通的方法：在函数内部再定义一个函数：
```js
function f1(){
    var n = 99;
    function f2(){
        console.log(n);
    }
}
```
上面代码中，函数 f2 在 f1 内部，这时候 f1 内部所有变量对于 f2 都是可见的。但是反过来就不行。这就是 js 语言特有的**链式作用域**结构，子对象会一级一级向上寻找所有父对象的变量。

正因为 f2 可以读取 f1 局部变量，所以可以将 f2 作为返回值，就可以在 f1 外部读取它的变量了。
```js
function f1(){
    var n = 99;
    function f2(){
        console.log(n);
    }
    return f2();
}
var result = f1();
result();
```
**闭包**就是函数f2。即能够读取其他函数内部变量的函数。由于 js 中只有函数内部的子函数才能够读取内部变量。因此可以简单地将闭包理解为“定义在一个函数内部的函数”。闭包最大的特点，就是它可以记住诞生的环境。如`f2`记住了环境`f1`。本质上，闭包就是将函数内部和函数外部链接起来的桥梁

闭包最大的用于有两个：**一**是可以读取函数内部的变量。**二**是让这些变量始终保持在内存中。即闭包可以让诞生的环境一直存在。

闭包的另一个用处是，**封装**对象的私有属性和私有方法。

**注意**，外层函数每次运行都会生成一个新的闭包。而这个闭包又会保留外层函数的内部变量，所以内存消耗很大。因此不能滥用闭包，否则会造成网页的性能问题。

## eval 命令

`eval`命令接收一个字符串作为参数，并将这个字符串作为语句执行。如果参数字符串无法作为语句执行则会报错。

`eval`没有自己的作用域，都是在当前作用域执行，因此有可能修改当前作用域的值。

