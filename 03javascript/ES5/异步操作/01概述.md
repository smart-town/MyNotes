# 异步操作概述

## 单线程模型

单线程模型指的是，`js`只在一个线程上运行。也就是说，js 同时只能执行一个任务。其他任务必须在后面排队等待。

注意，js 只在一个线程上运行并不代表 js 引擎只有一个线程，事实上，js 引擎有多个线程，单个脚本只能在一个线程上运行（主线程），其他线程都是在后台配合

js 之所以采用单线程而不是多线程，和历史有关。js 从诞生起就是单线程，原因是不想让浏览器变得太复杂。因为多线程需要共享资源、且有可能改变彼此运行的结果。对于一个网页脚本来说，这就太复杂了。如果 js 同时有两个线程，一个线程在 DOM 节点上增加内容，另一个线程删除了这些节点，此时应该以哪个为准？需要锁机制？所以为了避免复杂性，js 一开始就是单线程。

这种模式的好处是实现起来简单，执行环境相对单纯。坏处是只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的使用。常见的浏览器无响应，往往就是因为某段 js 长时间运行（如死循环），导致页面卡在这个地方其他任务无法执行。js 语言本身并不慢，慢的是读写外部数据，如等待 Ajax 请求返回结果，此时如果对方服务器迟迟没有响应那么就会导致脚本长时间延迟。

如果排队是因为计算量太大，CPU 忙不过来也就没什么问题，但是更多时候是因为 IO 操作很慢，不得不等待结果出来再去执行，js 设计者意识到这时候 cpu 完全可以不管 IO 操作，挂起处于等待中的任务，先运行排在后面的任务，等到 IO 返回后再将挂起的任务执行下去。这种机制就是 js 内部采用的**事件循环**机制，`Event loop`

单线程模型虽然对 js 构成了很大的限制，但是因此它也具备了其他语言不具备的优势。如果用得好，js 程序是不会阻塞的。这也是为什么 Node 可以用很少的资源，应付大流量访问的原因。

为了利用多核 CPU 的计算能力，HTML5 提出了 WebWorker 标准，允许 js 创建多个线程，但是子线程完全受主线程控制。且不得操作 DOM。所以这个新标准并没有改变 js 单线程的本质。

## 同步任务和异步任务

程序中所有的任务，可以分为两类：同步任务和异步任务。

同步任务是那些没有被引擎挂起，在主线程上排队执行的任务。只有前一个任务执行完毕后才能执行下一个任务。

异步任务是那些被引擎放在一边，不进入主线程，而进入任务队列的任务。只有引擎认为某个异步认为可以执行了，该任务才会进入主线程执行。排在异步任务后面的代码，不用等待异步任务结束会马上执行。

## 任务队列和事件循环

js 运行时，除了一个正在运行的主线程，引擎还提供了一个任务队列。里面是各种需要当前程序处理的异步任务。实际上，根据异步任务的类型，存在多个任务队列。这里假设只有一个任务队列

首先，主线程会去执行所有的同步任务。等到同步任务全部执行完，就会去看任务队列里面的异步任务。如果满足条件，那么异步任务就重新进入主线程开始执行。这时候它就变成同步任务了。等到执行完，下一个异步任务再进入主线程开始执行。一旦任务队列清空，程序就结束执行。

异步任务的写法通常是回调函数，一旦异步任务重新进入主线程，就会执行对应的回调函数。如果一个异步任务没有回调函数，就不会进入任务队列，也就是说，不会重新进入主线程。因为没有用回调函数指定下一步的操作。

js 如何知道异步任务有没有结果，能不能进入主线程呢?答案在于引擎在不停地检查，一遍又一遍，只要同步任务执行完了，引擎就回去检查那些挂起来的异步任务，是不是可以进入主线程了。这种循环检查的机制，叫做**事件循环**。

> 事件循环是一个程序结构，用来等待和发送消息和事件

## 异步操作的模式

### 回调函数

是异步操作的最基本的方法。其优点在于简单、容易理解和实现。缺点是不利于代码的维护和阅读。各个部分之间高度耦合，使得程序结构混乱，流程难以追踪。（尤其是多个回调函数嵌套的情况），而且每个任务只能指定一个回调函数。

### 事件监听

另一种思路是采用**事件驱动**模式，异步任务的执行不取决于代码的顺序，而取决于某个事件是否发生。以`f2`和`f1`为例，
```js
f1.on('done',f2) ; //为 f1 绑定一个事件

function f1(){
    setTimeout(function(){
        ...;
        f1.trigger('done');
    },1000);
}
```
上面代码中表示`f1`执行完后立即触发`done`事件，从而执行`f2`。

这种方法的优点是比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以**去耦合**。有利于实现模块化。缺点是整个程序都要变成事件驱动型。运行流程会变得很不清晰。阅读代码时，很难看出主流程。

### 发布/订阅

事件完全可以理解为“信号”，如果存在一个“信号中心”，某个任务执行完成，就向信号中心发布一个信号，其他任务可以向信号中心订阅这个信号。从而知道什么时候自己可以开始执行。这就是“发布订阅”模式。又称为**观察者模式**

这个模式有多种实现。

这种方法的性质与“事件监听”类似，但是明显优于后者，因为可以通过查看“消息中心”，了解存在多少个信号、每个信号有多少订阅者，从而监控程序运行。

## 异步操作的流程控制

如果有多个异步操作，就存在一个流程控制的问题：如何确定异步操作执行顺序，以及保证如何遵循这种顺序。

### 串行执行

编写一个流程控制函数，让它控制异步任务，一个任务完成之后，再执行另一个，这就是串行执行。

### 并行执行

流程控制函数也可以是并行执行，即所有的异步任务同时执行。

### 并行与串行的结合

所谓并行和串行的结合，就是设置一个门槛，每次最多只能并行执行`n`个任务。这样就避免了过分占用系统资源。

