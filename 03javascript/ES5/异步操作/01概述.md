# 异步操作概述

## 单线程模型

单线程模型指的是，`js`只在一个线程上运行。也就是说，js 同时只能执行一个任务。其他任务必须在后面排队等待。

注意，js 只在一个线程上运行并不代表 js 引擎只有一个线程，事实上，js 引擎有多个线程，单个脚本只能在一个线程上运行（主线程），其他线程都是在后台配合

js 之所以采用单线程而不是多线程，和历史有关。js 从诞生起就是单线程，原因是不想让浏览器变得太复杂。因为多线程需要共享资源、且有可能改变彼此运行的结果。对于一个网页脚本来说，这就太复杂了。如果 js 同时有两个线程，一个线程在 DOM 节点上增加内容，另一个线程删除了这些节点，此时应该以哪个为准？需要锁机制？所以为了避免复杂性，js 一开始就是单线程。

这种模式的好处是实现起来简单，执行环境相对单纯。坏处是只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的使用。常见的浏览器无响应，往往就是因为某段 js 长时间运行（如死循环），导致页面卡在这个地方其他任务无法执行。js 语言本身并不慢，慢的是读写外部数据，如等待 Ajax 请求返回结果，此时如果对方服务器迟迟没有响应那么就会导致脚本长时间延迟。

如果排队是因为计算量太大，CPU 忙不过来也就没什么问题，但是更多时候是因为 IO 操作很慢，不得不等待结果出来再去执行，js 设计者意识到这时候 cpu 完全可以不管 IO 操作，挂起处于等待中的任务，先运行排在后面的任务，等到 IO 返回后再将挂起的任务执行下去。这种机制就是 js 内部采用的**事件循环**机制，`Event loop`

单线程模型虽然对 js 构成了很大的限制，但是因此它也具备了其他语言不具备的优势。如果用得好，js 程序是不会阻塞的。这也是为什么 Node 可以用很少的资源，应付大流量访问的原因。

为了利用多核 CPU 的计算能力，HTML5 提出了 WebWorker 标准，允许 js 创建多个线程，但是子线程完全受主线程控制。且不得操作 DOM。所以这个新标准并没有改变 js 单线程的本质。

## 