# 对象的继承

## 构造函数缺点

js 通过构造函数生成对象，因此构造函数可以视为对象的模板，实例对象的属性和方法，可以定义在构造函数内部。

通过构造函数为实例对象定义属性，虽然方便，但是有一个缺点，同一个构造函数的多个实例之间，无法共享属性，从而造成对系统资源的浪费。

这个问题的解决方法就是`js`的**原型对象**

## `prototype`属性作用

js 继承机制的设计思想就是，原型对象的所有属性和方法，都能被实例对象共享，也就是说，如果属性和方法定义在原型上，那么实例对象就能共享，不仅节省了空间，还体现了实例对象之间的联系。

js 规定，每个函数都有一个`prototype`属性，指向一个对象。对于普通函数来说，该属性基本无用。但是对于构造函数来说，生成实例的时候，该属性会自动成为实例对象的**原型**

原型对象的属性不是对象自身的属性，只要修改原型对象，变动就会立刻体现在所有实例对象上。

当实例对象本身没有某个属性或者方法的时候，它会到原型对象上去寻找该属性或者方法，这就是原型对象的特殊之处。如果实例对象自身就有某个属性或者方法，它就不会再去原型对象寻找这个属性或者方法。

**总结**原型对象的作用，就是定义所有实例对象共享的属性和方法，这也是它被称为原型对象的原因。而实例对象可以视作从原型对象衍生出来的子对象。

## 原型链

js 规定，所有对象都有自己的原型对象。一方面，任何一个对象都可以充当其他对象的原型，另一方面由于原型对象也是对象，所以它也有自己的原型。因此形成一个“原型链”：对象到原型，再到原型的原型...

如果一层一层上溯，所有对象的原型最终都可以上溯到`Object.prototype`，即`Object`构造函数的`prototype`属性。也就是说，所有对象都继承了`Object.prototype`属性。这就是所有对象都有`valueOf`和`toString`的原因。

`Object.prototype`对象的原型是`null`。因此，原型链的尽头就是`null`。

读取对象的某个属性时，js 引擎首先去找对象本身的属性，如果找不到，就去它的原型对象中去找，如果还找不到，就去原型的原型去找。如果直到顶层的`Object.prototype`还是找不到，就返回`undefined`。如果对象自身和它的原型都定义了一个同名属性，那么优先读取对象自身的属性，这叫做“覆盖”，。

**注意**，一级级向上，在整个原型链上寻找属性，对性能是有影响的。所寻找的属性在越上层的原型对象，对性能的影响越大。如果寻找某个不存在的属性，将会遍历整个原型链。

## constructor 属性

`prototype`对象有一个`constructor`属性，默认指向`prototype`对象所在的构造函数。

```js
function P(){}
var p = new P();
p.constructor === P //true
p.constructor === P.prototype.constructor //true
p.hasOwnProperty('constructor') // false
```
`constructor`属性的作用是，可以得知某个实例对象，到底是哪个构造函数产生的。另一方面，有了`constructor`属性就可以从一个实例对象创建新实例。`new x.constructor()`

`constructor`属性表示原型对象与构造函数之间的关联关系，如果修改了原型对象，一般同时修改`constructor`属性，防止引用的时候出错。

