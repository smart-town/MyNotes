# History

## 1. 概述

`window.history`指向 History 对象，表示当前窗口浏览历史。由于安全原因，浏览器不允许脚本读取这些网址，但是允许在地址之间导航。

浏览器工具栏的前进和后退按钮，其实就是对 History 对象进行操作。

## 2. 属性

`History`主要有两个属性：`length`表示当前窗口访问过的网址数量（包括当前网页），`state`表示 History 堆栈最上层的状态值。

## 3. 方法

### `back()`、`forward()`、`go()`

- `back()`: 移动到上一个网址
- `forward()`: 移动到下一个网址
- `go()`: 接收一个整数作为参数，以当前网址为基准，移动到参数指定的网址。如`go(1)`相当于`forward()`。默认参数`0`相当于刷新当前页面。

注意，移动到以前访问过的页面时，页面通常是从浏览器缓存之中加载，而不是重新要求服务器发送新的网页。

### `pushState()`

该方法用于在历史中添加一条记录。该方法接受三个参数，依次为：
- `state`: 一个与添加的记录相关联的状态对象，主要用于`popstate`事件，该事件触发时，该对象会传入回调函数。也就是说，浏览器会将该对象序列化后保留在本地，重新载入这个页面的时候，可以拿到这个对象，如果不需要这个对象，此处可以填`null`
- `title`: 新页面的标题，但是，现在所有浏览器都忽视这个参数。可以填写空字符串
- `url`: 新网址，必须与当前页面在同一个域，浏览器地址栏将显示该网址。

#### 例子

假设当前网址为`example.com/1.html`，使用`history.pushState(stateObj,'page 2','2.html')`在浏览记录中添加一个新纪录，添加新纪录后，浏览器地址栏立刻显示`example.com/2.html`，但是并不会跳转到`2.html`，甚至也不会检查`2.html`是否存在，它只是成为浏览历史中最新的记录。

总之，**`pushState()`不会触发页面刷新，只是导致 History 对象发生变化，地址栏会有反应**。使用该方法后，可以使用`History.state`读取出状态对象。

如果`pushState`的 URL 参数设置了一个新的锚点值，即`hash`，并不会触发`hashchange`事件，反过来，如果 URL 锚点变了，则会在 History 对象中创建一条浏览记录。

**注意**如果`pushState()`设置了一个跨域网址，就会报错。这样设计的目的在于，防止恶意代码让用户以为他们是在另一个网站上。因为该方法不会导致页面跳转。

### `replaceState()`

`History.replaceState()`方法用来修改 History 对象当前记录，其他与 pushState() 一样。

## popstate 事件

每当同一个文档的浏览历史(`history`对象)出现变化时，就会触发`popstate`事件。

**注意**仅仅调用`pushState()`或`replaceState()`时，并不会触发该事件。只有`back()`、`forward()`、`go()`方法调用时才会触发。**另外，该事件只针对同一个文档，如果浏览历史的切换，导致加载不同的文档，该事件也不会触发**

回调函数的参数是一个`event`事件对象，它的`state`属性指向`replaceState`和`pushState`指定的状态对象。`state`对象可以通过`history`直接获取。