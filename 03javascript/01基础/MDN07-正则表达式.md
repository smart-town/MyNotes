# 正则表达式

正则表达式是用于匹配字符串中字符组合的模式，在JavaScript中正则表达式也是对象。这些模式被用于`RegExp`的`exec`和`test`方法。以及`String`的`math`、`replace`、`search`和`split`方法。

## 创建一个正则表达式

- 字面量`const regex = /ab+c/`
- `RegExp`构造函数：`let regex = new RegExp("ab+c");`

## 编写一个正则表达式的模式

一个正则表达式是由简单的字符所构成的，如`/abc/`，或者是简单和特殊字符的组合如`/ab*c/`或`/Chapter (\d+)\.\d*/`。后者用到了括号，它在正则表达式中可以被用作一个记忆设备，这一部分所匹配的字符将会被记住，在后面可以被使用。

### 使用简单模式

简单的模式是由你找到的直接匹配构成的。如`/abc/`这个模式就匹配了在一个字符串中，仅仅字符`abc`同时出现并按照这个顺序。在`"Hi,do you know abc's"`中就会被匹配到。

### 使用特殊字符

当你需要搜索一个比直接匹配需要更多条件的匹配的时候，比如寻找一个或者多个`b`，或者寻找空格，那么这时候将要包含特殊字符。

|字符|含义|
|----|----|
|`\`|在非特殊字符之前的反斜杠表示下一个字符是特殊的，不能从字面上解释。如`\b`表示匹配一个字符边界。反斜杠后面跟特殊字符则表示转义为字面量。使用new RegExp()时要注意将`\`进行转义，因为`\`在字符串里面也是一个转义字符|
|`^`|匹配输入的开始，如果多行标志被设置为true，那么也匹配换行符后面紧跟的位置。例如/^A/并不会匹配"an A"中的"A"，但是会匹配"An E"中的"A"。当^作为第一个字符出现在一个字符集合模式时将有不同的含义|
|`$`|匹配输入的结束。如果多行标志被设置为true，那么也匹配换行符前面的位置。如/t$/并不会匹配"eater"中的"t"但是匹配"eat"中的"t"|
|`*`|匹配前一个表达式 0 次或者多次，等价于{0,}。如/bo*/会匹配"A ghost boooooed"中的"booooo"和"A bird warbled"中的"b"但是在"A goat grunted" 中不会匹配任何东西。|
|`+`|匹配前面一个表达式 1 次或者多次。等价于{1,}。如/a+/匹配"candy"中的"a"，在"caaaandy"中的所有"a"|
|`?`|匹配前面一个表达式 0 次或者1次。等价于{0,1}。如/e?le?/匹配"angel"中的"el"和"angle"中的"le"以及"oslo"中的"l"。如果**紧跟在任何量词\*、+、?或者{}的后面**，这将使得量词变为**非贪婪**的，即匹配尽量少的字符，和缺省使用的**贪婪模式**恰好相反。例如对于"123abc"应用/\d+/将会返回"123"如果使用/\d+?/那么就会只匹配到"1"。还可以运用于**先行断言**。|
|`.`|匹配除换行符之外的任何单个字符。|
|`(x)`|匹配"x"并且记住匹配项。括号被称为**捕获括号**。模式/(foo) (bar) \1 \2/中的"(foo)"和"(bar)"匹配并记住字符串中的"foo bar foo bar"的前两个单词。模式中的\1和\2匹配字符串中的后两个单词。注意\1和\2是用在正则表达式的匹配环节。在正则表达式的**替换环节**中则要使用$1、$2这样的语法。如`"bar foo".replace(/(...) (...)/, "$2 $1");|
|`(?:x)`|匹配x但是不记住匹配项，叫做**非捕获括号**，使得你能够定义与正则表达式运算符一起使用的子表达式。如/(?:foo){1,2}/。如果表达式是/foo{1,2}/，{1,2}将只会对"foo"的最后一个字符"o"生效。如果使用非捕获括号则{1,2}会匹配整个"foo"单词|
|`x(?=y)`|匹配"x"仅仅当"x"后面跟着"y"，这叫做**正向肯定查找**。如/Jack(?=Sprat)/会匹配到"Jack"仅仅当它后面跟着"Sprat"。/Jack(?=Sprat|Front)/匹配"Jack"仅仅当它后面跟着"Sprat"或者"Front"，但是"Sprat"或"Front"都不是匹配结果的部分|
|`x(?!y)`|匹配"x"仅仅当"x"后面不跟着"y"这叫做**正向否定查找**。如/\d+(?!\.)/匹配一个数字仅仅当这个数字后面没有小数点。|
|`x|y`|匹配"x"或"y"，如/green|red/匹配"green apple"中的"green"和"red apple"中的"red"|
|`{n}`|n是一个正整数，匹配前面一个字符刚好发生了n次。如/a{2}/不会匹配"candy"中的"a"但是会匹配"caandy"中的"aa"|
|`{n,m}`||
|`[xyz]`|是一个字符集合，匹配方括号中的任意字符。包括转义序列。可以使用-表示一个范围，对于.和`*`这样的特殊符号在一个字符集中没有特殊意义，他们不必进行转义，不过转义也是起作用的。如`[abcd]`和`[a-d]`是一样的。
|`[^xyz]`|一个反向字符集，即匹配任何不包括在方括号中的字符。|
|`\b`|匹配一个词的边界，一个词的边界就是一个词不被另外一个”字“字符跟随的位置或者没有其他字符在其前面的位置。注意：一个匹配的词的边界并不包含在匹配的内容中，换句话说，一个匹配的词的边界的内容的长度是0.如/\bm/匹配"moon"中的"m";/oo\b/并不匹配"moon"中的"oo"，因为"oo"被一个字符"n"紧挨着。/oon\b/匹配"moon"中的"oon"|
|`\B`|匹配一个非单词边界，它匹配一个前后字符都是相同类型的位置：都是”字“字符或都都不是，一个字符串的开始和结尾都被认为不是”字“字符，或者空字符串。如/\B../匹配"noonday"中的"oo"而/y\B../匹配"possibly yesterday"中的yes|
|`\d`|匹配一个数字字符。等价于`[0-9]`。如/\d/匹配"B2 is the suit number"中的"2"|
|`\D`|匹配一个**非数字字符**|
|`\n`|换行符|
|`\s`|匹配一个空白字符，包括空格、制表符、换页符、换行符|
|`\w`|匹配一个单字字符（字母、数字、下划线）等价于`[A-Za-z0-9_]`|


*查找字符串，所以首先需要对字符串进行描述，即匹配什么样的字符串，再加上其他条件，这个字符串后面有什么没什么，这个字符串匹配多少次。*

## 使用正则表达式

正则表达式可以被用于`RegExp`的`exec`和`test`方法以及`String`中的`match`、`replace`、`search`和`split`方法。

|方法|描述|
|----|----|
|`exec`|执行查找匹配，返回一个数组（未匹配到则返回null）|
|`test`|测试是否匹配，返回true或false|
|`match`|执行查找匹配，返回一个数组或在未匹配到时返回null|
|`search`|测试匹配，返回匹配到的索引或者未匹配到时的-1|
|`replace`|一个字符串中执行查找匹配的String方法并且使用替换字符串替换掉匹配到的子字符串|
|`split`|使用正则表达式或一个固定字符串分割一个字符串，并将分隔后的子串存储到数组中|

当你想要知道一个字符串中的一个匹配是否被找到，可以使用`test`或者`search`方法，想要得到更多的信息（比较慢）则可以使用`exec`或者`match`方法。如果你使用`exec`或`match`方法成功了，那么这些方法会返回一个数组并且更新相关的正则表达式属性和预定义的表达式对象，如果匹配失败则返回`null`。

```js
var myRe = /d(b+)d/g;
var myArray = myRe.exec("cdbbdbsbz") ;
```

如果不需要访问正则表达式的属性，可以这样创建`myArray`:`var myArray = /d(b+)d/g.exec("cdbbdbsbz")`;

如果你想通过一个字符串构建正则表达式，可以这样：

```js
var myRe = new RegExp("d(b+)d","g") ;
var myArray = myRe.exec("...") ;
```

通过这些脚本匹配成功后将返回一个数组并且更新正则表达式的属性。

### 使用括号的子字符串匹配

一个正则表达式使用括号将导致相应的子匹配被记住。使用括号匹配的子字符串数量是无限的，返回的数组中保存着所有被发现的子匹配。

```js
var re = /(\w+)\s(\w+)/ ;
var str = "John Smith";
var newStr = str.replace(re, "$2,$1") ;
console.log(newStr);//"Smith,John"
```

### 通过标志进行高级搜索

正则表达式有四个可选参数进行全局和不分大小写搜索。这些参数都可以单独使用也可以一起使用在任何顺序和包含正则表达式的部分中。

|标志|描述|
|----|----|
|`g`|全局搜索|
|`i`|不区分大小写|
|`m`|多行搜索|
|`y`|”粘性“搜索，匹配从目标字符串的当前位置开始，可以使用y标志|

需要注意的是，标志是一个正则表达式的一部分，它在接下来的时间里不能被添加或删除。

包含标志的正则表达式：`var re = /pattern/flags`或`var re = new RegExp("pattern","flags") ;`

如 `re = /\w+\s/g`将创建一个查找一个字符或多个字符后面由一个空格的正则表达式。

```js
var re = /\w+\s/g ;
var str =  "fee fi fo fum";
var myArray = str.match(re) ;
console.log(myArray) ; //["fee ","fi ","fo "]
```