# 良好的类接口

创建高质量的类，第一步也可能是最重要的一步，就是创建一个好的接口。这也包括了创建一个可以通过接口来展现的合理的抽象，并确保细节仍然被隐藏在抽象背后。

## Goob Abstraction

抽象是一种以简化的形式来看待复杂操作的能力。类的接口为隐藏在其后的具体实现提供了一种抽象。类的接口应能够提供一组明显相关的子程序。

你可以有一个实现雇员(Employee)这一实体的类，其中可能包含雇员的姓名、地址、电话号码等数据，以及一些用来初始化并使用雇员的服务子程序。

在类的内部还可能会有支持这些服务的其他子程序和数据，但是类的使用者并不需要了解它们。类接口的抽象能力非常有价值，因为接口中的每个子程序都在朝着这个一致的目标而努力。

一个没有经过良好抽象的类诶坑你会包含有大量混杂的函数。

**类的接口应该展现一致的抽象层次** 在考虑类的时候有一种很好的方法，就是将类看做一种用来实现抽象数据类型的机制。每一个类应该是先一个 ADT，并且仅实现这个 ADT，如果你发现某个类实现了不止一个 ADT，或者你不能确定究竟它实现了何种 ADT，你就应该把这个类重新组织委员一个或者多个定义更加明确的 ADT。

**一定要理解类所实现的抽象是什么** 一些类非常相像，你必须非常仔细地理解类的接口应该捕捉的抽象到底是哪个。

**提供成对的服务** 大多数操作都有和其对应的、相等的以及相反的操作。如果有一个操作用来将灯打开，那么很可能也需要另一个操作将灯关闭。在设计一个类的时候，要检查每一个公用子程序，决定是否需要另一个与其互补的操作。不要盲目地创建相反操作，但是一定要考虑，看看是否需要它。

**将不相关的信息转移到其他类中** 有时候你会发现，某个类中的一半子程序使用着该类的一般数据，而另一半子程序则使用另一半数据。这时候你其实已经把两个类混在一起使用了，将它们拆开叭。

**尽可能让接口可编程，而不是表达语义** 每个接口都由一个可编程的部分和一个语义的部分组成。可编程的部分由接口中的数据类型和其他属性构成，编译器能够强制性要求它们（在编译时检查错误），而语义部分则由“本接口将会被怎样使用”的假定组成，而这些是无法通过编译器来强制实施的。语义接口中的考虑比如，A 必须在 B 之前被调用等。语义接口应该通过注释说明，但是要尽可能不依赖于这些说明。一个接口中任何无法通过编译器强制实施的部分，就是一个可能被误用的部分。要想办法将语义接口的元素转换为编程接口的元素，比如说用`Assert`或其他技术。

**谨防在修改时破坏接口的抽象** 在对类进行修改和扩展的过程中，你常常会发现额外所需的一些功能。这些功能并不十分适用于原有的类接口，可看上去也很难用另一种方法来实现。

**同时考虑抽象性和内聚性** 抽象性和内聚性这两个概念之间的关系非常紧密——一个呈现出很好的抽象的类接口通常也有很高的内聚性。而具有很强内聚性的类也往往呈现出很好的抽象。

## Good Encapsulation 良好的封装

封装是一个比抽象更强的概念，**抽象通过提供可以让你忽略细节的模型来管理复杂度，而封装则强制阻止你看到细节。**

这两个概念只是多疑相关，是因为没有封装时，抽象往往很容易打破。一般来说，要么就是封装和抽象两者皆有，要么就是两者皆失。

**尽可能限制类和成员的可访问性** 让可访问性(`accessibility`)尽可能低是促成封装的原则之一。当你犹豫某个子程序的可访问性应该设为公用、私有或受保护时，经验之举是应该采用更严格且可行的访问级别。更好的一个建议是，考虑**采用哪种方式能最好地保护接口抽象的完整性**，如果暴露一个子程序不会让抽象变得不一致的话，那么这样做就是可行的。如果你不确定，那么多隐藏通常比少隐藏要好。

**不要公开暴露成员数据** 暴露成员数据会破坏封装性，从而限制你对这个抽象的控制能力。

**避免把私用的实现细节放入类的接口中** 做到真正的封装以后，程序员们是根本看不到任何实现细节的。无论是字面上还是喻意上，它们都被隐藏了起来。