# 良好的类接口

创建高质量的类，第一步也可能是最重要的一步，就是创建一个好的接口。这也包括了创建一个可以通过接口来展现的合理的抽象，并确保细节仍然被隐藏在抽象背后。

## Goob Abstraction

抽象是一种以简化的形式来看待复杂操作的能力。类的接口为隐藏在其后的具体实现提供了一种抽象。类的接口应能够提供一组明显相关的子程序。

你可以有一个实现雇员(Employee)这一实体的类，其中可能包含雇员的姓名、地址、电话号码等数据，以及一些用来初始化并使用雇员的服务子程序。

在类的内部还可能会有支持这些服务的其他子程序和数据，但是类的使用者并不需要了解它们。类接口的抽象能力非常有价值，因为接口中的每个子程序都在朝着这个一致的目标而努力。

一个没有经过良好抽象的类诶坑你会包含有大量混杂的函数。

**类的接口应该展现一致的抽象层次** 在考虑类的时候有一种很好的方法，就是将类看做一种用来实现抽象数据类型的机制。每一个类应该是先一个 ADT，并且仅实现这个 ADT，如果你发现某个类实现了不止一个 ADT，或者你不能确定究竟它实现了何种 ADT，你就应该把这个类重新组织委员一个或者多个定义更加明确的 ADT。

**一定要理解类所实现的抽象是什么** 一些类非常相像，你必须非常仔细地理解类的接口应该捕捉的抽象到底是哪个。

**提供成对的服务** 大多数操作都有和其对应的、相等的以及相反的操作。如果有一个操作用来将灯打开，那么很可能也需要另一个操作将灯关闭。在设计一个类的时候，要检查每一个公用子程序，决定是否需要另一个与其互补的操作。不要盲目地创建相反操作，但是一定要考虑，看看是否需要它。

**将不相关的信息转移到其他类中** 有时候你会发现，某个类中的一半子程序使用着该类的一般数据，而另一半子程序则使用另一半数据。这时候你其实已经把两个类混在一起使用了，将它们拆开叭。

**尽可能让接口可编程，而不是表达语义** 每个接口都由一个可编程的部分和一个语义的部分组成。可编程的部分由接口中的数据类型和其他属性构成，编译器能够强制性要求它们（在编译时检查错误），而语义部分则由“本接口将会被怎样使用”的假定组成，而这些是无法通过编译器来强制实施的。语义接口中的考虑比如，A 必须在 B 之前被调用等。语义接口应该通过注释说明，但是要尽可能不依赖于这些说明。一个接口中任何无法通过编译器强制实施的部分，就是一个可能被误用的部分。要想办法将语义接口的元素转换为编程接口的元素，比如说用`Assert`或其他技术。

**谨防在修改时破坏接口的抽象** 在对类进行修改和扩展的过程中，你常常会发现额外所需的一些功能。这些功能并不十分适用于原有的类接口，可看上去也很难用另一种方法来实现。

**同时考虑抽象性和内聚性** 抽象性和内聚性这两个概念之间的关系非常紧密——一个呈现出很好的抽象的类接口通常也有很高的内聚性。而具有很强内聚性的类也往往呈现出很好的抽象。

## Good Encapsulation 良好的封装

封装是一个比抽象更强的概念，**抽象通过提供可以让你忽略细节的模型来管理复杂度，而封装则强制阻止你看到细节。**

这两个概念只是多疑相关，是因为没有封装时，抽象往往很容易打破。一般来说，要么就是封装和抽象两者皆有，要么就是两者皆失。

**尽可能限制类和成员的可访问性** 让可访问性(`accessibility`)尽可能低是促成封装的原则之一。当你犹豫某个子程序的可访问性应该设为公用、私有或受保护时，经验之举是应该采用更严格且可行的访问级别。更好的一个建议是，考虑**采用哪种方式能最好地保护接口抽象的完整性**，如果暴露一个子程序不会让抽象变得不一致的话，那么这样做就是可行的。如果你不确定，那么多隐藏通常比少隐藏要好。

**不要公开暴露成员数据** 暴露成员数据会破坏封装性，从而限制你对这个抽象的控制能力。

**避免把私用的实现细节放入类的接口中** 做到真正的封装以后，程序员们是根本看不到任何实现细节的。无论是字面上还是喻意上，它们都被隐藏了起来。

**不要对类的使用者作出任何假设** 类的设计和实现应该符合在类的接口中所隐含的契约，它不应该对接口会被如何使用或者不会被如何使用做出任何假设——除非在接口中有过明确说明。

**不要因为一个子程序仅使用公用子程序，就将它归入公开接口** 一个子程序仅仅使用公用的子程序这一事实并不是十分重要的考虑因素，相反，应该问的问题是，把这个子程序暴露给外界后，接口所展示的抽象是否还是一致的。

**让阅读代码比编写代码更方便** 阅读代码的次数要比编写代码多得多，即使在开发的初期也是如此。因此为了让编写代码更方便而降低代码的可读性是非常不经济的。尤其是在创建类的接口时，即使某个子程序与接口的抽象不很匹配，有时候人们也往往把这个子程序加到接口中，从而让正在开发的这个类的某处调用代码能更方便使用它。然而，这段子程序的添加正是使得代码走下坡路的开始，所以还是不要走出这一步比较好

**要格外警惕从语义上破坏封装性** 学会避免语法错误仅仅是个开始，接踵而来的是无以计数的编码错误，而其中大多数错误逗比语法错误更难于诊断和更正。比较起来，语义上的封装性和语法上的封装性二者的难度相差无几。从语法的角度来说，要想避免窥探另一个类的内部实现细节，只要把它内部的子程序和数据类型都声明为 `private` 就可以了，这是相对容易办到的。然而，要想达到语义上的封装性就完全是另外一回事了。以下是一些类的调用方代码从语义上破坏封装性的例子：
- 不去调用 A 类的`InitializeOperations()`子程序，因为你知道 A 类的`PerformFirstOperation()`子程序会调用它
- 不在调用`employee.Retrieve(database)`之前调用`database.connect()`子程序，因为你知道在未建立数据库连接的时候`employee.Retrieve()`会去连接数据库的
- 不调用 A 类的`Terminate()`子程序，因为你知道 A 类的`PerformFinal.Operation()`已经调用过了。

以上的例子问题在于，它们让调用方代码不是依赖于类的公开接口，而是依赖于类的私用实现。每当你发现自己是通过查看类的内部实现来得知该如何使用这个类的时候，你就不是在针对接口编程了，而是在**透过**接口针对内部实现编程了。如果你透过接口来变成，封装性就被破坏了，而一旦封装性开始遭到破坏，抽象能力也就快遭殃了。

如果仅仅根据类的接口文档还是无法得知如何使用一个类的话，正确的做法不是拉出这个类的源代码，从中查看其内部实现。这是一个好的初衷，但却是一个错误的决断。正确的做法应该是去联系类的作者，告诉他“我不知道该如何使用这个类”，而对于类的作者而言，正确的做法不是面对面告诉你的答案，而是从代码库中检出接口文件，修改类的接口文档。

**留意过于紧密的耦合关系** “耦合”(coupling)指的是两个类之间关联的紧密程度，通常，这种关联越松越好。根据这一概念可以得出以下一些指导建议：
- 尽可能限制类和成员的可访问性
- 避免友元类，因为它们之间是紧密耦合的
- 在基类中将数据声明为`private`而不是`protected`，以降低派生类和基类之间的耦合程度
- 避免在类的公开接口中暴露成员数据
- 要对从语义上破坏封装性保持警惕

耦合性与抽象和封装性有着密切的联系，紧密的耦合总是发生在抽象不严谨或者封装性遭到破坏的时候。如果一个类提供了一套不完整的服务，其他的子程序就可能要去直接读写一个该类的内部数据。这样一来就把类给拆开了，把它从一个黑盒子变成了一个玻璃盒子，从而事实上消除了类的封装性。
