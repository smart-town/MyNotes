# 有关设计和实现

## Member Functions and Data 成员函数和数据成员

**让类中的子程序数量尽可能减少**

**禁止隐式地产生你不需要的成员函数和运算符**

**减少类所调用的不同子程序的数量** 

**对其他类的子程序的间接调用要尽可能少** 直接的关联已经够危险了，而间接的关联，如`aacount.ContactPerson()`往往更加危险。研究人员据此总结一条`Demeter`法则，基本上就是说**A对象可以任意调用它自己的所有子程序。如果A 对象创建了一个 B 对象那么它也可以调用 B 对象的任何公有子程序，但是他应该避免再调用由 B 对象提供的对象中的子程序**。以`account.ContactPerson()`来说，其是合适的，但是`account.ContactPerson().DaytimeContactInfo()`则不合适。

**一般来说，应尽量减小类和类之间相互合作的范围** 尽量让以下几个数字最小：
- 所实例化的对象的种类
- 在被实例化对象上直接调用的不同子程序的数量
- 调用其他对象返回的对象的子程序的数量

## Constructors 构造函数

以下是一些只适用于构造函数的建议。

**如果可能，应该在所有的构造函数中初始化所有的数据成员** 

**用私有构造函数来强制实现单件属性** 如果你想定义一个类，并需要强制规定它只能有唯一一个对象实例的话，可以把该类所有的构造函数都隐藏起来，然后对外提供一个`static`的`GetInstance()`子程序来访问该类的唯一实例。

**优先采用深层复本，除非论证可行，才采用浅层复本 shallow copies** 在设计复杂对象的时候，你需要作出一项主要决策，即应该为对象实现深拷贝还是浅拷贝，对象的深层复本是对象成员数据逐项复制的结果，而浅层复本往往只是指向或引用同一个实际对象。  
实现浅层复本的动机一般是为了改善性能，尽管把大型对象复制出多份复本看起来十分令人不快，但是这样做很少会导致显著的性能损失。  
为了不确定的性能提高而增加复杂度是不妥的，因此，在面临选择实现深拷贝还是浅拷贝时，一种合理的方式就是优先实现深拷贝。
