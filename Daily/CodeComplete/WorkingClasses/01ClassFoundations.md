# 类的基础

类的基础：抽象数据类型（ADTs Abstract Data Types）

抽象数据类型是指一些数据以及对这些数据所进行操作的集合。这些操作既向程序的其余部分描述了这些数据是怎么样的，也允许程序的其余部分改变这些数据。“抽象数据类型”概念中“数据”一词的用法有些随意，一个 ADT 可能是一个图形窗体以及所有能影响该窗体的操作；也可以是一个文件以及对这个文件进行的操作；或者是一张保险费率表以及相关操作。

要想理解面向对象编程，首先要理解 ADT，不懂 ADT 的程序员开发出来类只是定义上的“类”而已，实际上这种类只不过是把一些稍有点关系的数据和子程序堆在一起。然而在理解 ADT 之后，程序员就能够写出在一开始很容易实现，日后也易于修改的类来。

传统的编程教科书在讲到抽象数据类型时，总会用一些数学中的事情打岔。这些书往往会这样写：你可以将抽象数据类型想成一个定义有一组操作的数学模型。这种书会给人一种感觉，好像你从不会真正用到抽象数据类型似的。

将抽象数据类型解释得这么空洞完全丢失了重点。抽象数据类型可以让你像在现实世界中一样操作实体，而不必在低层的实现上摆弄实体，这多么令人兴奋。你不必再向链表中插入一个节点，而是可以在电子表格中添加一个数据单元格，或者向一组窗体中添加一个新类型。

## 需要用到 ADT 的例子

看看 ADT 在什么情况下会非常有用。例子：

假设你在写一个程序，它能用到不同的字体、字号、属性来控制显示在屏幕上的文本。程序的一部分功能是控制文本的字体，如果你用一个 ADT ，你就能有捆绑在相关数据上的一组操作字体的子程序——有关的数据包括字体名称、字号、文字属性等，这些子程序和数据合为一体就是一个 ADT。

如果不使用 ADT 你就只能用一种拼凑的方法来操纵字体了，比如，如果要将字体大小改为 12 磅，即 16 像素，你就要写类似的这样的代码：`currentFont.size = 16`，如果你已经开发了一套自程序库，那么代码可能会稍微好看一些：`currentFont.size = PointsToPixels(12)`。或者你还可以给该属性一个更特定的名字，比如：`currentFont.sizeOnPixels = PointsToPixels(12)`，但是你不能同时使用`sizeInPixels`和`sizeInPoints`，因为如果同时使用这两项数据成员，`currentFont`就无法判断到底该使用那个了。而且，如果你在程序的很多地方都需要修改字体的大小，那么这类语句就会散布在整个程序中。

如果你要将字体设置为粗体，或许会这样写：`currentFont.attribute = CurrentFont.attribute or 0x02`，就修改字体大小而言，这些做法都会存在一个限制，即要求调用方法码直接控制数据成员，这无疑限制了`currentFont`的使用。

如果你这样编写程序的话，程序中很多地方就会充斥着类似的代码。

## 使用 ADT 的好处

问题并不在于拼凑法是种不好的编程习惯，而是说你可以采用一种更好的编程方法来替代这种方法，从而获得下面这些好处：

**可以隐藏实现细节** 将关于字体数据类型的信息隐藏起来，意味着如果数据类型发生改变，你只需要在一处修改而不会影响到整个程序。例如，除非你把实现细节隐藏在一个 ADT 中，否则当你需要把字体类型从粗体的第一种表示变为第二种表示时，就不可避免地要更改程序中所有设置粗体字体的语句，而不能仅在一处修改。把信息隐藏起来能够保护程序的其余部分不受到影响，即使你想把在内存里存储的数据改为在外存储，或者你想将所有操作字体的子程序用另一种语言重写，也都不会影响程序的其余部分。

**改动不会影响到整个程序** 如果想要让字体更丰富，而且能支持更多操作（例如变成小型大写字母，上标等）时，只需要在程序的一处进行修改即可，这一改动也不会影响到程序的其余部分。

**让接口能够提供更多信息** 像 `currentFont.size = 16`这样的语句是不够明确的，因为此处 16 的单位既可能是像素也可能是其他单位，语句所处的上下文环境并不能告诉你是哪一种单位。把所有相似的操作都集中在一个 ADT 中就可以让你基于磅数或者像素数定义整个接口，或者将二者明确分开从而有助于避免混淆

**更容易提高性能** 如果你想提高操作字体时的性能，就可以重新编写出一些更好的子程序，而不用来回修改整个程序

**让程序的正确性更显而易见** 验证像`currentFont.attribute = 0x02`这样的语句是否正确是很枯燥的，你可以替换成像`currentFont.SetBoldOn()`这样的语句，验证它是否正确相对容易一些，对于前者你可能写错结构体或者数据项名字，或者写错值，但是对于后者在调用函数时唯一可能出错的地方就是写错方法，因此识别它更容易一些。

**程序更具有自说明性** 

**无须在程序内到处传递数据**

**可以像在现实世界中那样操作实体而不用在低层实现上操作他**： 你可以定义一些针对字体的操作，这样程序的绝大部分就可以完全以“真实世界中的字体”这个概念来草祖宗，而不再用数组访问、结构体定义、`True`与`False`等这些低层的实现概念了。这样一来，为了定义一个抽象数据类型，你只需要定义一些用来控制字体的子程序——多半就像这样：`currentFont.setGBoldOn()`、`currentFont.setBoldOff()`等。这些子程序中的代码可能很短，可能就像拼凑法控制字体时所写的代码。这里的区别在于，你已经把对于字体的操作**隔离到一组子程序中，**，这样就为需要操作字体的**其他部分程序提供了更好的抽象层**，同时它也可以在针对字体的操作发生变化时提供一层保护。

## Handling Multiple Instance of Data with ADTs in Non-Object-Oriented Environments

在非面向对象环境中用 ADT 处理多份数据实例

面向对象的编程语言能够自动支持对同一 ADT 的多份实例处理。如果你只是在面向对象的环境中工作，那么你根本不用操心处理多个实例的实现细节了。如果你是在像 C 语言这样的非面向对象的环境中工作，你就必须自己手工实现支持处理多个实例的技术。一般来说，这就意味着你要为 ADT 添加一些用来创建和删除实例的操作，同时需要重新设计 ADT 的其他服务操作，使其能够支持多个实例。

## ADTs and Classes

抽象数据类型构成了“类/class”这一概念的基础，在支持类的编程语言中，你可以将每个抽象数据类型用它自己的类实现。类还涉及到继承和多态这两个额外的概念。因此，考虑类的另一种方式，就是把它看作是抽象数据类型再加上继承和多态这两个概念。

