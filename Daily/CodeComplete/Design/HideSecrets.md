# Hide Secrets(Information Hiding)

**信息隐藏是结构化程序设计和面向对象设计的基础之一**。

**信息隐藏是软件的首要技术使命中格外重要的一种启发式方法，因为它强调的就是隐藏复杂度，这一点无论是从他的名称还是实施细节上都能看的很清楚**

## Secrets and the Right to Privacy 秘密和隐私权

当信息被隐藏后，每个类（或者包、子程序）都代表了某种对其他类保密的设计或构建决策。隐藏起来的秘密可能是某个易变的区域，或者某种文件格式，或者某种数据类型的实现方式，或者某个需要隔离的区域，在这个区域中发生的错误不会给程序其余部分带来太大损失，在这里类的之职责就是讲这部分信息隐藏起来，并保护自己的隐私权。对于系统的非重大改动可能会影响到某个类中的几个子程序，但是它们不应该波及到类接口的外面。

在设计一个类的时候，一个关键性的决策就是确定类的哪些特性应该可以对外可见，而哪些应该隐藏起来。在类的设计中，这一方面也称为“可见性”，因为他要确定的就是类的哪些特性对外界是“可见的”或能“暴露”给外界。

类的接口应该尽可能少地暴露其内部工作机制。类很像冰山：八分之七都是位于水面之下，而你只能看到水面上的八分之一。

设计类的接口与其他设计环节一样，都是一个迭代的过程。如果你第一次没有得到合适的接口，那么就多试几次，直到设计稳定下来，如果设计仍然不稳定，那么你就需要换种方法再试。

信息隐藏在设计的所有层次上都有很大的作用——从用具名常量代替字面量，到创建数据类型，再到类的设计、子程序的设计以及子系统的设计等等。

## Two Categories of Secrets

信息隐藏总所说的秘密主要分为两大类：

- 隐藏复杂度，这样你就不用应付它，除非你需要特别关注的时候
- 隐藏变化源，这样当变化发生的时候，其影响就能被限制在局部范围内。复杂度的根源包括复杂的数据类型、文件结构、布尔判断以及晦涩的算法等等。

## Barriers to Information Hiding 信息隐藏的障碍

在少数情况下，信息隐藏是根本不可能的。不过大多数让信息无法隐藏的障碍是由于惯用某些技术而导致的心理障碍。

**信息过度分散**信息隐藏的常见障碍之一是信息在系统内过度分散。你可能将 100 这个数字直接写到了程序中，这样会导致对它的引用过于分散。最好是把这部分信息隐藏起来，比如写入一个叫做`MAX_EMPLOYEES`这个常量中，而对于这个常量的值进行改动只要在一处进行即可。

信息过度分散的另一个例子是在系统内部到处都有与人机交互相关的内容。一旦交互方式改变——比如说从图形用户界面变为命令行界面——那么几乎所有的代码都需要变动。最好是将人机交互逻辑集中到一个单独的类、包或者子系统中，这样改动就不会给系统带来全局性的影响了。

**循环依赖** 一种更为隐晦的信息隐藏障碍则是循环依赖，比如说 A 类中的子程序调用了 B 类中的子程序。然后 B 类中的子程序又调用了 A 类的子程序。要避免形成这种循环依赖，这会让系统难于测试。因为你既无法单独测试 A 类，也无法单独测试 B 类，除非另一个类中至少已经部分就绪。

**将类中数据误认为全局数据** 如果你是一个谨慎的程序员，那么有效地隐藏信息的障碍之一就是将类内数据误认为是全局数据并避免使用它，因为你想避免全局数据可能带来的问题。全局变量会让你陷入很多编程陷阱，而类内数据可能带来的风险则要小很多。

全局数据通常会受困于两类问题：一种是子程序在全局数据之上执行操作，但是却不知道还有其他的子程序也在用这些全局数据进行操作；另一种是子程序知道其他的子程序也在用全局数据进行操作，但是却无法明确知道都进行了哪些操作。而类内数据就不会遇到这种问题，因为只有类内部少数的子程序才能直接访问这些数据。这些子程序不但知道有其他子程序在操纵这些数据，而且也明确知道具体是哪些子程序在执行这些操作。

不过上述观点所基于的前提是：你的系统使用了设计良好的、体积小巧的类。如果你的程序被设计为使用了很多体积庞大、包含众多子程序的类的话，那么类数据和全局数据之间的区别就变得模糊起来，类内数据也将开始受困于全局数据所面临的那些问题了。

**可以觉察的性能损耗** 信息隐藏的最后一个障碍是试图在系统架构层和编码层均避免性能上的损耗。你不必在任何一层去担心，因为在架构层按照信息隐藏的目标去设计系统并不会与按照性能目标去设计相冲突。如果你谨记信息隐藏和性能这两点，那么就可以达到这两个目标。

更常见的担心来自于编码层，你可能认为，由于有了额外层次的对象实例化和子程序调用等，间接访问对象会带来性能上的损耗，事实上，这种担心为时尚早，因为你能够衡量系统的性能，并且找出妨碍性能的瓶颈所在之前，在编码层为性能目标所做的最好的准备，就是作出高度模块化的设计出来。等你日后找到了性能的瓶颈，你就可以针对个别的类或者子程序进行优化而不会影响系统的剩余部分了。

## Value of Information Hiding

信息隐藏是少数几个得到公认的、在实践中证明了其自身价值的理论技术，并且已经有了很长一段时间了。几年前人们就发现，那些运用了信息隐藏技术的大型项目与没有应用这一技术的项目相比，修改起来大约容易 4 倍。而且信息隐藏还是结构化程序设计和面向对象设计的根基之一。

信息隐藏有着独特的启发力，它能够激发出有效的设计方案。传统的面向对象设计通过把周围世界建模为对象来激发设计，但是这种基于对象的思考却不能帮助你避免将 ID 声明为 int 而不是 IdType。面向对象设计者会这么问：“能否将 ID 看做是一个对象？”取决于这个项目的编码标准，如果回答了“是的”，那么可能就意味着程序员必须写构造函数、析构函数、拷贝操作符和赋值操作符；注释掉所有的原有语句然后放回源码控制系统中。大多数的程序员可能会决定：“不，没有必要为了一个 ID 而新建一个类，我还是用 int 得了”

看看都发生了什么。一个能够简单地将 ID 的数据类型隐藏起来的有用的设计方案甚至都没有被考虑。可是如果设计者改变一下问法，“如果 ID 应该被隐藏起来该怎样呢？”，那么他很可能会用 IdType 来取代 int，即用一个简单的类型声明来隐藏 ID 的类型。在这个例子中，面向对象设计与信息隐藏之间的差异，要比规章与临时制度之间的差异还要微妙。面向对象设计也会和信息隐藏一样接受这种设计方案。两者间的区别更多的是在于，按照信息隐藏的原则来思考，能够激发和促进某些设计决策的形成，而仅仅按照对象原则思考却不会。其差异也很有启发性。

信息隐藏也同样有助于设计类的公开接口。在设计类的理论和实践之间有着很大的差距，有很多类的设计者认为，将什么内容放进类的公开接口中，就等同于找出使用最方便的那个接口，这通常就导致类内部过多的内容被暴露出来。以我看来，一些程序员宁愿将私有数据都暴露出来，也不愿意多写十行代码来保护类的秘密不被泄露。

问题“**这个类需要隐藏什么**”，正切中了几口设计的核心。如果你嗯能够在给定类的公开接口中增加函数或者数据而不牺牲该来的隐秘星，那么久做下去，否则请停住。

在设计的所有层面，都可以通过询问该隐藏些什么来促成良好的设计决策。这一问题可以在构建层面上协助你用具名常量来取代字面量，可以在类的内部生成好的子程序和参数名称，还有助于知道在系统层上作出有关类和子系统分解以及交互设计的决策。

**请养成“我该隐藏些什么”的习惯**，你会发现，很多棘手的设计难题都会在你的面前化解。

