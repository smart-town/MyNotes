# 设计构造块：启发式方法

由于软件设计是非确定性的，因此，灵活熟练地运用一组有效的启发式方法（试探法），便成了合理的软件设计的核心工作。以下是几个启发式的方法，也即时一些思考问题的方法，他们有时候能够产生优秀设计成果。

## 1. Find Real-World Objects 找出现实世界中的对象

在确定设计方案时，首选且流行的一种做法就是“常规的”面向对象设计方法，此方法的要点是辨识现实世界中的对象以及人造的对象。步骤：

- 辨识对象及其属性（方法和数据）
- 确定可以对各个对象进行的操作
- 确定各个对象能对其他对象进行的操作
- 确定对象的哪些部分对其他对象可见——哪些部分是公用的，哪些部分是使用的
- 定义每个对象的公开接口(public interface)

这些捕捉并无须以特定顺序完成，它们也经常被反复执行，迭代是非常重要的。

## 2. Form Consistent Abstractions

抽象是一种能让你在关注某一概念的同时可以放心地忽略其中一些细节的能力——在不同层次处理不同的细节。任何时候当你在对一个聚合物品工作时，你就是在用抽象了。当你把一个东西称为“房子”而不是由玻璃、木材和钉子构成的组合体时，你就是在用抽象了。

基类也是一种抽象，它能够使得你集中精力关注一组派生类所具有的共同特性，并在基类的层次上忽略各个具体派生类的细节。一个好的接口也是一种抽象，它能让你关注与接口本身而不是类的内部工作方式。一个设计良好的子程序接口也在较低的层次上提供了同样的好处，而设计良好的包 package 和子系统的接口则在更高的层次上提供了同样的好处。

以复杂度的观点来看，抽象的主要好处就在于它使你能够忽略无关的细节。大多数现实世界中的物体都已经是某种抽象了，正如上面所提到的，房屋是由门、窗、墙、线路、管道等物体以及特定的组织方式所形成的抽象。

人们一直都在使用抽象，如果每天你开门的时候都要单独考虑那些木纤维、油漆分子以及铁原子的话，你就别想再出入房间了。**抽象是我们用来得以处理现实世界中复杂度的一种重要手段**

软件开发人员有时候就是在木材纤维、油漆分子、铁原子这一层来构建系统，系统因此变得十分复杂，难以通过人的智力去管理。当程序员没有给出足够高层的编程抽象时，系统有时候就被卡到门口了。

优秀的程序员会在子程序接口的层次上、在类接口的层次上以及包接口的层次上——换句话说，在门把手的层次上、门的层次上以及房屋的层次上——进行抽象，这样才能更快、更稳妥地进行开发。

## 3. 封装实现细节

封装填补了抽象留下的空白，抽象是说：“可以让你从高层次的细节来看待一个对象”。而封装则是说：“除此之外，比不能看到对象的任何其他细节层次”

继续关于房屋材质的比喻：封装是说，你可以从房屋的外面来看，但是不能靠的太近去把门的细节看清楚。可以让你知道哪里有门，让你知道门是开着的还是关着的，但是不能让你知道门是什么材质的。

**封装帮助你管理复杂度的方法是不让你看到那些复杂度**。

**封装是说，不只是让你能用简化的视图来看复杂的概念，同时还不能让你看到复杂概念的任何细节，你能看到的就是你能全部得到的**

## 4. 当继承能够简化设计时就继承 Inherit——When Inheritance Simplifies the Design

在设计软件系统时，经常会发现一些大同小异的对象。比如说，账务系统中包含全职员工和兼职员工，两者大多数数据相同，只是某些数据不同。在面向对象编程时，你可以定义一个代表普通员工的通用类型，然后将全职员工定义为普通员工——除了有一些不同之处；同样也将兼职员工也定义为普通员工——除了一些不同之处。当一项针对员工的操作与具体的员工类别无关时，这一操作就可以仅针对通用员工类型进行。当该做做需要区别全职员工与兼职员工时，就需要按照不同的方法来处理了。

**定义这种对象之间的相同点和不同点就叫做继承**，因为特殊的全职员工类型和特殊的兼职员工类型都从基本员工类型继承了某些特征。

继承时面向对象编程中最强大的工具之一，如果使用得当，它能带来极大的益处，然而如果使用不当，它也有极大的弊端。

## 5. 信息隐藏

**信息隐藏时结构化程序设计与面向对象设计的基础之一**。结构化设计里面的“黑盒子”概念就是源于信息隐藏，在面向对象设计中它又引出了封装和模块儿化的概念，并与抽象的概念紧密相关。信息隐藏是软件开发中一个开拓性的概念。

[更多](./HideSecrets.md)

## 6. 找出容易改变的区域

对优秀的设计师一份研究表明，他们所共有的一项特质就是都有对于变化的预期能力。**好的程序设计所面临的最重要挑战之一就是适应变化。目标应该是把不稳定的区域隔离出来，从而把变化所带来的影响限制在一个子程序、类或者包的内部**

1. **找出看起来容易变化的项目** 如果需求做的很好，那么其中就应该包含一份潜在变化的清单，已经其中每一项发生变化的可能性。在这种情况下，找出潜在的变化就很容易了
2. **将容易变化的项目分离出来** 将第一部中找出的容易变化的组件单独划分为类，或者和其他同时容易发生变化的组件划分到同一个类中。
3. **将看起来容易变化的项目隔离开来** 设法设计好类之间的接口，使其对于潜在的变化不敏感。设计好类的接口，将变化限制在类的内部，且不会影响类的外部。任何使用了这个将会发生变化的类的其他类都不会觉察到变化的存在。类的接口应该肩负起保护类的隐私的责任。

[更多](./IdenfityAreasLikelyToChange.md)

## 7. 保持松散耦合

[更多](./KeepCouplingLoose.md)

## 8. 查阅常用的设计模式

[详细](./LookForCommonDesignPattern.md)