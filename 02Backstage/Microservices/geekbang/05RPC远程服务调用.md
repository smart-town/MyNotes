# RPC 远程服务调用

要完成一次服务调用，首先要解决的问题是服务消费者如何得到服务提供者的地址，其中注册中心扮演了关键角色，服务提供者将自己的地址登记到注册中心，服务消费者就可以查询注册中心得到服务提供者的地址，可以说注册中心又如海上的一座灯塔，为服务消费者指引了前行的方向。

有了服务提供者的地址后，服务消费者就可以向这个地址发起请求了，但是这个时候也产生了一个新的问题。单体应用时，一次服务调用发生在同一台机器的同一个进程内部，也就是说调用发生在本机内部，因此也叫本地方法调用。在进行服务化拆分后，服务提供者和服务消费者运行在两台不同物理机的不同进程内，他们之间的调用相比于本地方法调用，可以称为远程方法调用，即 RPC(Remote Procedure Call)

我们习惯上叫服务消费者叫做客户端，服务提供者叫做服务端，两者通常位于网络上不同的两个地址，要完成一次 RPC 调用，就必须先建立网络连接，建立连接后，双方还必须按照某种约定的协议进行网络通信，这个协议就是通信协议。双方能够正常通信后，服务端接收到请求时，需要以某种方式进行处理，处理成功后，将请求结果返回给客户端，为了减少传输的数据大小，还要对数据进行压缩也就是序列化。

以上就是 RPC 调用的过程，由此可见要完成调用，需要解决：
- 客户端和服务端如何建立网络连接
- 服务端如何处理请求
- 数据传输采用什么协议
- 数据该如何序列化和反序列化

## 建立网络连接

客户端和服务端之间基于 TCP 协议建立网络连接最常用的途径有两种：

### HTTP 通信

HTTP 通信基于应用层 HTTP 协议，而 HTTP 协议又是基于传输层 TCP 协议，一次 HTTP 通信过程就是发起一次 HTTP 调用，而一次 HTTP 调用就会建立一个 TCP 连接。

### Socket 通信

Socket 通信是基于 TCP/IP 协议的封装，建立一次 Socket 连接至少需要一对套接字，其中一个运行于客户端，称为 ClientSocket，另一个运行与服务端，称为 ServerSocket。Socket 通信过程分为四个步骤：服务器监听、客户端请求、连接确认、数据传输

当客户端和服务端建立网络连接后，就可以发起请求了，但是网络不一定总是可靠的，经常会遇到网络闪断、超时等异常，通常处理手段有两种：
- 链路存活检测：客户端需要定时发送心跳检测信息（一般通过 ping 请求）给服务端，如果服务端连续 n 次心跳检测或者超过规定时间都没有回复消息，则认为次链路已经失效，这时候客户端就需要重新与服务端建立连接
- 断联重试：通常有多种情况会导致连接断开，比如客户端主动关闭、服务端宕机或者网络故障等。这时候客户端就需要与服务端重新建立连接，但是一般不能立刻完成重连，而是要等待固定间隔后再发起重连，避免服务端的连接回收不及时，而客户端瞬间连接的请求太多而把服务端连接数占满

## 服务端如何处理请求

假设客户端和服务端此时已经建立了网络连接，服务端又该如何处理客户端的请求呢？通常有三种方式：

- 同步阻塞方式(BIO): 客户端每发一次请求，服务端就生成一个线程去处理。当客户端同时发起的请求很多时，服务端需要创建很多的线程去处理每一个请求，如果达到了系统最大线程数瓶颈，新来的请求就没法处理了
- 同步非阻塞方式(NIO): 客户端每发一次请求，服务端并不是每次都创建一个新线程来处理，而是通过 I/O 多路复用技术进行处理，就是将多个 IO 阻塞服用到同一个 select 的阻塞上，从而使得系统在单线程的情况下可以同时处理多个客户端请求，这种方式的优势是开销小，不用为每个请求创建一个线程，可以节省系统开销
- 异步非阻塞方式(AIO): 客户端只需要发起一个 IO 操作然后立即返回，等 IO 操作真正完成后，客户端会得到 IO 操作完成的通知，此时客户端只需要对数据进行处理就好了，不需要进行实际的 IO 读写操作，因为真正的 IO 读取或者写入操作已经由内核完成了。这种方式的优势是客户端无需等待，不存在阻塞等待的问题

根据经验：
- BIO 适合用于连接数比较小的业务场景，这样的话不至于系统中没有可用线程去处理请求，这种方式写的程序也比较简单直观，易于理解
- NIO 适用于连接数比较多且请求消耗比较轻的业务场景，如聊天服务器，这种方式相比 BIO 相对来说编程比较复杂
- AIO 适用于连接数比较多且请求消耗比较重的业务场景，比如涉及 IO 操作的相册服务器，这种方式相比另外两种，编程难度最大，程序也不易理解

上面两个问题就是“通信框架”要解决的问题，你可以基于现有的 Socket 通信，在服务消费者和提供者之间建立网络连接，然后在服务提供者一侧基于 BIO、NIO 或 AIO 中任意一种实现服务端请求处理，最后再花费一些精力去解决服务消费者和服务提供者之间的网络可靠性问题。这种方式对于 Socket 网络编程、多线程编程知识都要求比较高。更稳妥的方式是使用成熟的开源方案，如 Netty、MINA 等，他们都是经过业界大规模应用后，被充分论证是很可靠的方案。

假设服务端和客户端连接已经建立了，服务端也能正确处理请求了，接下来要完成一次正常的 RPC 调用还需要解决两个问题，即数据传输采用什么协议以及数据该如何序列化和反序列化

## 数据传输采用什么协议

最常用的有 HTTP 协议，还有一些定义的私有协议如阿里巴巴的 Dubbo 协议。无论是开放的还是私有的协议，都必须定义一个“契约”，以便服务消费者和服务提供者之间能够达成共识。服务提供者从网络上接收到数据后，按照契约，对传输的数据进行解码，然后处理请求，再把处理后的结果进行编码，通过网络传输返回给消费者；消费者再对返回的结果进行解码，最终得到服务提供者处理后的返回值。

通常协议契约包括两个部分：消息头和消息体。消息头用来存放协议公共字段以及用户扩展字段，消息体存放的是传输数据的具体内容。

## 数据该如何序列化和反序列化

一般数据在网络中进行传输前，都要先在发送方一端对数据进行编码，经过网络传输到达另一端后，再对数据进行解码，这个过程就是序列化和反序列化。

为什么要对数据行序列化和反序列化呢？要知道网络传输的耗时一方面取决于网络带宽的大小，另一方面取决于数据传输量。要想加快网络传输，要么提高带宽，要么减小数据传输量。而对数据进行编码的主要目的就是减小数据传输量。

常用的序列化方式分为：文本类如 XML/JSON 等，二进制类如 PB/Thrift，而具体采用哪种序列化方式，则主要取决于三方面：
- 支持数据结构的丰富度
- 跨语言支持
- 性能

## 总结

- **通信框架**：解决客户端和服务端如何建立连接、管理连接以及服务端如何处理请求等问题
- **通信协议**：解决客户端和服务端采用何种数据传输协议问题
- **序列化和反序列化**： 解决客户端和服务端采用哪种数据编码解码的问题

这三部分组成了一个完整的 RPC 调用框架，通信框架提供了基础的通信能力，通信协议描述了通信契约，而序列化和反序列化则用于数据的编解码。一个通信框架可以适配多种通信协议，也可以采用多种序列化和反序列化的格式。如服务化框架 Dubbo 不仅支持 Dubbo 协议，还支持 RMI、HTTP 协议等。