# 异常

## 来源

## 异常分类

`Throwable`、`Error`、`Exception`、`RuntimeRxception`、`IOException`

**受查异常** 和 **非受查异常**

一个方法必须声明所有可能**抛出**的**受查异常**，而**非受查异常**要么不可控制`Error`，要么就应该避免发生`RuntimeException`。如果方法没有生命所有可能发生的受查异常，编译器就会发出一个错误消息。当然，除了抛出，还可以**捕获异常**。

## 抛出异常

找到一个合适的异常类，创建这个类的对象，将对象抛出即可。

### 创建异常类

定义一个派生于`Exception`或派生于`Exception`子类的类即可。

习惯上定义的类应该包含两个构造器，一个是默认的构造器，一个是带有详细描述信息的构造器。超类`Throwable`的`toString`方法会打印出这些消息，这在调试中非常有用。

## 捕获异常

抛出异常十分容易，只要抛出就不必理会了，但是有些代码必须捕获异常，**捕获异常需要进行周密的计划**。如果某个异常发生的时候没有地方捕获，那么程序就会终止执行。

`try...catch` 语句，捕获多个异常`catch`可以合并。

### 再次抛出异常

在`catch`子句中可以抛出一个异常，这样做的目的是为了改变抛出异常的类型。推荐`e.initCause(e)`包装要重新抛出的异常，这样可以让用户抛出自定义的高级异常，且不会对是原始异常。可以通过`e.getCause()`获得原始异常。

### finally 子句

建议解耦和`try/catch`和`try/finally`语句块：
```java
InputStream in = ...;
try {
    try {
        //code that might throw exceptions
    }
    finally {
        in.close();
    }
} catch(IOException e) {...}
```
内层的`try`语句块只有一个职责，就是确保关闭输入流。外层的`try`语句块也只有一个职责，就是确保报告出现的错误。这种设计方式不仅清楚，而且还具有一个功能，就是会报告`finally`子句中出现的错误。

**注意** `finally`子句包含`return`的情况。假设利用`return`语句从`try`中返回，在方法返回前，`finally`子句中的内容会被执行，如果`finally`子句中也有一个`return`语句，那么这个返回值就会覆盖原始的返回值。

### 带资源的 try 语句

假设资源属于一个实现了`AutoClosable`接口的类，Java SE 7 为这种代码模式提供了一种很有用的快捷方式：带资源的`try`语句：
```java
try (Resource res = ...) {
    work with res
}
```
`try`块退出时，会自动调用`res.close`。

只要需要关闭资源，就要尽可能使用带资源的`try`语句。

## 使用异常机制的技巧

1. 异常处理不能代替简单的测试（捕获异常花费时间大大超过简单的测试），只在异常情况下使用异常机制。
2. 利用异常层次结构，不要只抛出`RuntimeException`，应该寻找更加合适的子类或创建自己的异常类。