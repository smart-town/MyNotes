# 散列集

链表和数组可以按照人们的意愿排列元素的次序，但是如果想要查看某个指定的元素，却又忘记了它的位置，那么就需要访问所有的元素，直到找到为止。如果集合中包含的元素很多，将会消耗很多时间，如果不在意元素的次序，可以有集中能够快速查找元素的数据结构，缺点是无法控制元素的次序。

一种众所周知的数据结构，可以快速查找所需要的对象，这就是**散列表**。散列表为每个对象计算一个整数，称为**散列码**，散列码是由对象实例域产生的一个整数，更准确地说，具有不同数据域的对象将产生不同的散列码，如果自定义类，就要负责实现这个类的`hashCode`方法。注意自己实现的`hashCode`应该与`equals`兼容，即`a.equals(b)`那么`a`和`b`应该有一样的哈希码

在 Java 中，散列表用**链表数组**实现，每个列表被称为**桶**，要想查找表中对象的位置，就要先计算它的散列码，然后与桶的总数取余，所得到的结果就是保存这个元素的桶的索引。如某个对象的散列码为`76268`,并且有`128`个桶，对象应该保存在 108 号桶中。或许很幸运，在这个桶中没有其他元素，此时将元素直接放到桶中就可以了，当然有时候会遇到桶被占满的情况，这也是不可避免的，这种现象称为**散列冲突**，这时候需要用新的对象与桶中所有对象进行比较，看这个对象是不是已经存在，如果散列码是合理且随机分布的，桶的数目也够大，那么需要比较的次数就比较少。

如果想要更多控制散列表的运行性能，就要指定一个初始的桶数。桶数是指用于收集具有相同散列值的桶的数目，如果要插入到散列表中的元素太多，就会增加冲突的可能，降低运行性能。如果大致知道最终有多少个元素插入到散列表中，可以设置桶数。通常将桶数设置为元素个数的 75%~150%，默认的值为 16.

**再散列**，创建一个桶数更多的表，将所有元素插入到新表中，并丢弃原来的表。装填因子决定何时对散列表进行再散列。

散列表可以用于实现几个重要的数据结构，其中最简单的是 set 类型。