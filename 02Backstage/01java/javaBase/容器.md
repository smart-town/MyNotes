# 容器

## 1. 认识

## 2. 常见容器
### 2.1 整体分类
名称 | 描述
---- | ----
`List` | **对付顺序的好帮手** `List` 接口存储不唯一（可以有多个元素引用相同的对象），有序的对象。
`Set` | **注重独一无二的性质** 不允许重复的集合。不会有多个元素引用相同的对象
`Map` | **用Key来搜索的专家** 使用键值对存储，`Map`会维护与`Key`有关联的值。`key`可以是任何对象，通常是`String`
### 2.2 并发常见
名称 | 描述
---- | ----
`ConcurrentHashMap` | 线程安全的`HashMap`
`CopyOnWriteArrayList` | 线程安全的`List`，在读多写少的场合性能非常好。远远好于`Vector`
`ConcurrentLinkedQueue` | 高效的并发队列，使用链表实现。可以看做一个线程安全的`LinkedList`。是一个**非阻塞队列**
`BlockingQueue` | **阻塞队列**，非常适合用于作为数据共享的通道。JDK 内部通过链表、数组等方式实现了这个接口。
`ConcurrentSkipListMap` | **跳表**的实现。是一个`Map`，使用跳表的数据结构进行快速查找。

## 3. 常见容器基础知识
### 3.1 ArrayList&LinkedList
- **线程安全** 两者都是不同步的，即不保证线程安全
- **底层数据结构** `ArrayList`用的是`Object[]`数组，`LinkedList`使用**双链表**结构。
- **插入和删除是否受元素位置影响** `ArrayList`采用数组存储，所以插入和删除元素的时间复杂度受元素位置影响。如：`add(e)`时，默认在列表末尾添加指定元素，这种情况下复杂度就是`O(1)`。但是如果在指定位置`i`插入或删除元素：`add(int index, E element)`，时间复杂度就是`O(n-i)`。因为在指定位置添加或删除元素后，要对之后的`n-i`个元素执行向前或向后的移位操作。 `LinkedList`使用的是链表存储，删除元素复杂度近似`O(1)`。如果在指定位置`i`插入和删除则复杂度近似`O(n)`，因为要先移动到指定位置再插入。
- **是否支持随机访问** `LinkedList`不支持高效的随机访问。
- **内存空间占用** `ArrayList`对空间的浪费主要体现在`list`列表结尾会预留一定空间，而`LinkedList`本身每个元素就要消耗更多空间。
### 3.2 ArrayList&Vector

## 4. 常见并发容器基础知识

