# 关于类

## 自定义类

### 隐式参数与显式参数

### 封装的优点

需要注意返回值为可变的引用时，则应当返回其克隆值

### 关于私有和共有的使用

使用私有确保其他人使用本类的稳定性？

## 静态域与方法

### 静态域

`static`，每个类只有一个这样的域，而每一个对象对于所有的实例域都有一份自己的拷贝。

### 静态常量

静态变量使用得较少，静态常量使用得较多。如`Math.PI`

### 静态方法

静态方法是一种不能向对象实施操作的方法。如`Math.pow(x,a)`计算对应值，不使用任何`Math`对象，换句话说没有**隐式参数**

使用的两种情况：
- 一个方法不需要访问对象状态，其所需参数都是通过显式参数提供的
- 一个方法只需要访问类的静态域

### 工厂方法

静态方法另外一种常见的用途就是**静态工厂方法**，进行构造对象。其主要有两种原因：无法命名构造器、当使用构造器时无法改变所构造的对象类型

## 方法参数

两种情况**按值调用**和**按引用调用**

Java 程序设计语言总是采用**按值调用**，即方法得到的是所有参数值的一个拷贝。特别是，方法不能修改传递给它的任何参数变量的内容。

但是方法的参数有两种类型：**基本数据类型**和**对象引用**。对象引用作为参数时，方法得到是引用的拷贝，实际上指向的是同一个独享，因此可以进行修改。

误区，可能会认为 Java 还是使用了引用传递，证明：
```java
public static void swap(Employee x, Employee y){
    Employee temp = x ;
    x = y ;
    y = temp ;
}
swap(x1,y1) ;
```
实际使用会发现并没有改变互换 x1 和 y1，因为实际 x，y是引用的拷贝。

## 对象构造

### 重载

如果多个方法有**相同的名字**、**不同的参数**，便产生了重载。编译器必须挑出具体执行那个方法，它通过用各个方法给出的参数类型和特定方法调用所使用的值类型进行匹配来挑选出相应的方法。如果编译器找不到匹配的参数，就会产生编译错误。（这个过程称为**重载解析**）

注意：
Java 允许冲在任何方法，而不只是构造器方法。因此要完整描述一个方法，需要指出方法名以及参数类型。这叫做方法的**签名**，需要注意返回类型不是方法签名的一部分，即不能有两个名字相同、参数类型也相同但是返回类型不同的方法。

### 默认域初始化

如果没有在构造器中显式地给域赋值，那么就会被自动地赋为**默认值**，数值为 0 、布尔值为 false、对象引用为 null。

### 无参构造器

很多类都包含一个无参数的构造器，对象由无参数构造器创建时状态会设置为适当的默认值。如果在编写一个类时没有编写构造器，那么系统就会**提供**一个无参数构造器。这个构造器将所有实例域设置为默认值。

如果类中提供了至少一个构造器，但是没有提供无参数的构造器，则在构造对象的时候如果没有提供参数就会被视为不合法。

### 调用另一个构造器

关键字`this`是引用方法的隐式参数，然而，这个关键字还有另外一个含义。如果构造器的第一个语句形如`this(...)`，那么这个构造器将调用同一个类的另一个构造器。

### 初始化数据域

- 构造器中设置值
- 声明中赋值
- 初始化块`initialization block`

需要注意执行顺序，

- 数据域被初始华为默认值
- 按照类中出现的次序，一次执行所有域初始化语句和初始化块
- 构造函数


### 对象析构与 finalize 方法

有些面向对象语言如 C++ 有显式的析构器方法，其中放置一些当对象不再使用时需要执行的代码。在析构器中最常见的操作是回收分配给对象的存储空间，由于 Java 有自动的垃圾回收器，不需要人工回收内存，所以 Java 不支持析构器

当然，某些对象使用了内存之外的资源，如文件使用了系统的另一个对象的句柄，这种情况下，当资源不再需要是，将其回收利用将很重要。

可以为任何一个类添加`finalize`方法，该方法将会在垃圾回收器清除对象之前调用。

实际应用中，不要依赖于使用`finalize`方法回收任何稀缺资源，因为很难知道这个方法什么时候才会被调用。

通常某个资源需要使用完毕后要立即关闭，那么需要人工管理。

