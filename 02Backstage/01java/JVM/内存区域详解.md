# JVM 内存区域详解

## 概述
对于 Java 程序员来说，在虚拟机自动昂内存管理机制下，不需要像在`C/C++`程序中为每个`new`操作写对应的`delete/free`操作，不容易出现内存泄露和溢出的问题。但也正是由于将内存控制权交给了虚拟机，一旦出现了内存泄露和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会是一个很艰巨的任务。
## 运行时数据区域
### 概览
Java 虚拟机在执行 Java 程序的过程中会将它管理的内存划分为若干不同的数据区。
![JVM运行时数据区域.png](./JVM运行时数据区域.png)
![Java运行时数据区域JDK1.8.png](./Java运行时数据区域JDK1.8.png)

**线程私有的**：    
- 程序计数器
- 虚拟机栈
- 本地方法栈 

**线程共享的**：    
- 堆
- 方法区
- 直接内存

### 程序计数器
当前线程所执行的字节码的行号指示器。**字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理等都需要依赖这个计数器完成**

另外，**为了线程切换后能够恢复到正确的位置，每条线程都需要独立的程序计数器，各线程之间的计数器互不影响，独立存储**

**是唯一一个不会出现`OutOfMemoryError`的区域。
### 虚拟机栈/本地方法栈

### 堆
虚拟机所管理内存最大的一块。是虚拟机所有线程共享的一块内存区域，**其唯一目的就是存放对象实例，几乎所有的对象实例和数组都在这里分配内存**。

Java 堆是垃圾收集器管理的主要区域，因此也被称为**GC 堆**.`Garbage Collected Heap`。从垃圾回收的角度，由于收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代。再细致一点：`Eden`空间、`From Survior`、`To Survior`。**进一步划分空间是为了更好地回收内存、或更快地分配内存**

JDK 7 及之前，堆内存通常分为：    
1. 新生代(Yong Generation)
2. 老生代(Old Generation)
3. 永生代(Permanent Generation)

JDK 8 之后的方法区（HotSpot 的永久代）被彻底移除了，取而代之的是**元空间**，其使用的是直接内存。

大部分情况下，对象都会首先在`Eden`区域分配，在一次新生代垃圾回收后，如果对象还存活则进入`s0`或`s1`，并且对象的年龄还会加 1.

### 方法区
用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 **Java 虚拟机规范将其描述为堆的一个逻辑部分**

方法区也称为**永久代**。两者之间的关系：永久代是 HotSpot 的概念，方法区是 Java 虚拟机规范中的定义，是一种规范，而永久代是一种实现。