# 类加载过程

## 类加载过程-加载

在加载阶段，虚拟机需要完成以下 3 件事情：  
- 通过一个类的全限定名获取定义此类的二进制字节流
- 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
- 在内存中生成一个代表这个类的`java.lang.Class`对象，作为方法区这个类的各种数据的访问入口

虚拟机规范的这 3 点要求并不算具体，因此虚拟机实现与具体应用的灵活度都是相当大的。如第一条，并没有指明二进制字节流从哪里获取，因此有各种各样的实现，如从 ZIP 包中获取，这称为 JAR、WAR 的基础；运算时生成，这种场景用的最多的就是动态代理技术。

相对于类加载过程的其他阶段，一个非数组类的加载阶段(加载阶段中获取类的二进制字节流的动作)是开发人员可控性最强的。因为加载阶段既可以使用系统提供的引导类加载器完成，也可以由用户自定义的类加载器完成。开发人员可以通过自定义的类加载器控制字节流的获取方式(重写类加载器的`loadClass()`方法)

对于数组类而言，情况有所不同，数组类本身不通过类加载器创建，而是通过虚拟机直接创建。但是数组类和类加载器仍然有很密切的关系，因为数组类的元素最终要靠类加载器完成。一个数组类(下面简称C)创建过程：  
如果数组的组件类型是引用类型，那就递归采用这里的加载过程加载这个组件类型。数组 C 会在加载该组件类型的类加载器的类名称空间上被标识。【一个类必须与类加载器一起确定唯一性】  
如果数组的组件类型不是引用类型，Java 虚拟机会将 C 标记为与引导类加载器关联。

加载阶段完成后哦，虚拟机外部的二进制字节流就会按照虚拟机所需的格式存储在方法区中，方法区中的数据存储格式由虚拟机实现自定义。然后在内存中实例化一个`java.lang.Class`类的对象(并没有规定在堆中)，对于 HotSpot 虚拟机而言，Class 对象比较特殊，它虽然是对象，但是存放在方法区中，这个对象将作为程序访问方法区中这些类型数据的外部接口。

加载和连接阶段的部分内容是交叉进行的，加载阶段尚未完成连接阶段可能已经开始。这两个阶段的开始时间保持着固定的先后顺序。

## 验证

验证是连接阶段的第一步，这一阶段的目的是确保 Class 文件的字节流信息中包含的信息符合当前虚拟机要求，并且不会危害虚拟机自身安全。

Java 语言本身是相对安全的语言，使用纯粹的 Java 代码无法做到诸如访问数组边界以外的数据、将一个对象转型为它并未实现的类型、跳转到不存在的代码行之类的事情，如果这样做了编译器将拒绝编译，但是 Class 文件并不一定要求 Java 源码编译而来，可以使用任何途径产生。在字节码语言层面上，上述 Java 代码无法做到的事情都是可以做到的。虚拟机如果不检查输入的字节流，对其完全信任的话，很可能会因为载入了有害的字节流而导致系统崩溃，所以验证是虚拟机对自身保护的一项重要工作。

验证阶段是非常重要的，这个阶段是严谨，直接决定了虚拟机是否能够承受恶意代码攻击，从执行性能角度讲，验证阶段的工作量在虚拟机的类加载子系统中又占了相当大的一部分。

对于虚拟机的类加载机制来说，验证阶段是一个非常重要的，但不是必要的阶段。如果所运行的全部代码都已经反复使用和验证过，那么实施时可以使用`-Xverify:none`参数来关闭大部分的类验证措施，以缩短虚拟机加载时间。

## 准备

准备阶段是正式为类变量分配内存并设置类变量初始值的阶段。这些变量所使用的内存都将在方法区中进行分配。

这时候进行的内存分配**仅仅包括类变量**(static)，而不包括实例变量。实例变量会在对象实例化时随着对象一起分配到 Java 堆中。这里所说的初始值通常是数据类型的**零值**

如`public static int value=123`，在准备阶段过后，`value`的初始值是`0`，而`value`赋值为`123`的指令是程序编译后，存放于类构造器`<clinit>()`方法中，所以`value`赋值为`123`将在初始化时才执行。

但是对于一些**特殊情况**，如果类字段的字段属性表中存在`ConstantValue`属性，那么准备阶段就会赋值为`ConstantValue`所指定的值。如`public static final value=123;`

## 解析

解析阶段是虚拟机将常量池中的符号引用替换为直接引用的过程。

符号引用：以一组符号描述所引用的目标，符号可以是任何形式的字面量，只要引用时能无歧义定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标不一定已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能够接受的符号引用都必须是一致的。因为符号引用的字面量形式明确定义在虚拟机规范的 Class 文件格式中。  
直接引用：是可以指向目标的指针、相对偏移量或能间接定位到目标的句柄。直接引用是和虚拟机实现的内部布局有关的。如果有了直接引用，那么引用的目标必定已经在内存中存在。

......

## 初始化

类初始化阶段是类加载过程的最后一步，前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作都是由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的 Java 程序代码。

在准备阶段，变量已经赋予过一次系统要求的初始值，而在初始化阶段，则根据程序员通过程序制定的主观计划去初始化类变量和其他资源。或者从另外一个角度来表达：初始化阶段执行类构造器`<clinit>()`的过程。

`<clinit>()`方法是由编译器自动收集类中所有类变量的赋值动作和静态语句块`static{}`中的语句合并而成。编译器收集的顺序是有语句在源文件中出现的顺序所决定的。静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句可以对它赋值但是不能访问。

`<clinit>()`与构造函数(或者说`<init>()`方法)不同，它不需要显式调用父类构造器，虚拟机会保证`<clinit>()`执行之前对应的父类`<clinit>()`方法已经执行完毕。因此在虚拟机中第一个被执行的`<clinit>()`一定是`java.lang.Object`

由于父类的`<clinit>()`优先执行，这也就意味着父类中定义的静态语句块优先于子类的变量赋值操作。`<clinit>()`不是必须的，如果一个类中没有 静态语句块也没有对变量的赋值操作，那么编译器可以不为这个类生成`<clinit>()`方法。

