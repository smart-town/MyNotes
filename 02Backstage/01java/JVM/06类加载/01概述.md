# 概述

虚拟机将描述类的数据从 Class 文件加载到内存，并对数据进行校验，转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这就是虚拟机的类加载机制。

与在编译时需要进行连接工作的语言不同，在 Java 中，类型的加载、连接和初始化过程都是在程序运行期间完成的，这种策略虽然会让类加载时稍微增加一些性能开销，但是会为 Java 应用程序提供高度的灵活性。Java 里天生可以动态扩展的语言特性就是依赖运行期间动态加载和动态链接这个特点实现的。如：如果编写一个面向接口的应用程序，可以等到运行时再指定其实际的实现类；用户可以通过 Java 预定义的和自定义类加载器，让一个本地的应用程序可以在运行时从网络或者其他地方加载一个二进制流作为程序代码的一部分，这种组装应用程序的方式目前已经广泛应用于 Java 程序中。

## 加载时机

类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载`Loading`、验证`Verification`、准备`Preparation`、解析`Resolution`、初始化`Initialization`、使用`Using`、卸载`Unloading`七个阶段。其中验证、准备、解析统称为**连接**。`Linking`

加载、验证、准备、初始化、卸载这五个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始。而解析阶段不一定，它在某些情况下可以初始化之后在开始，这是为了支持 Java 的**运行时绑定**。这些阶段通常是互相交叉地混合式进行的，通常会在一个阶段执行的过程中调用、激活另外一个阶段。

何时需要开始类加载过程的第一个阶段：加载？JVM 规范中并没有进行强制约束，这个可以交给虚拟机的具体实现来把握，但是对于初始化阶段，JVM 规定了有且只有 5 种情况必须立即对类进行“初始化”。（加载、验证、准备自然需要在此之前完成）:
- 遇到`new`、`getstatic`、`putstatic`、`invokestatic`这 4 条字节码指令时，如果类没有进行进行过初始化，则需要首先触发其初始化。生成这 4 条指令的最常见的 Java 代码场景是：使用`new`关键字实例化对象、读取或设置一个类的静态变量、调用一个类的静态方法时。
- 使用`java.lang.reflect`包的方法对类进行反射调用时，如果累没有进行过初始化则要进行初始化
- 初始化一个类时，如果发现其父类还没有进行过初始化，则要先触发父类的初始化
- 虚拟机启动时，用户需要指定一个要执行的主类，虚拟机会先初始化这个类
- 动态语言支持时，如果`java.lang.invoke.MethodHandle`实例最后的解析结果`REF_getStatic`、`REF_setStatic`、`REF_inokeStatic`方法句柄对应的类没有进行初始化则要进行。

除此之外，所有引用类的方式都不会触发初始化，称为**被动引用**

`-XX:+TraceClassLoading`参数可以观察类加载。

接口的加载过程与类加载过程稍微不同，针对接口需要做一些特殊说明。接口也有初始化过程，接口与类真正有所区别的是初始化场景中的第三种：当一个类在初始化时会要求其父类都已经初始化完成了。但是一个接口在初始化时，并不要求其父类都已经初始化过，只有真正使用到父接口时才会初始化。

