# 阻塞队列

对于实际编程来说，应该尽可能远离底层结构。使用由并发处理的专业人士实现的较高层次的结构要方便、安全很多。

对于许多线程问题，可以通过使用一个或者多个队列以优雅且安全的方式将其形式化，生产者线程向队列插入元素，消费者线程则取出它们。使用队列，可以安全地从一个线程向另一个线程传递数据。

当试图向队列元素添加元素而队列已满，或是想要从队列移除元素而队列为空时，**阻塞队列**导致线程阻塞。在协调多个线程之间的合作时，阻塞队列是一个有用的工具。工作者线程可以周期性地将中间结果存储到阻塞队列中，其他工作者线程移出中间结果并进一步加以修改。队列会自动**平衡负载**，如果第一个线程集运行的比第二个慢，第二个线程集在等待结果时会阻塞。如果第一个线程集运行的块，它将等待第二个队列集赶上来。

如银行转账的例子，转账线程将转账指令对象插入到一个队列中，而不是直接访问银行对象。另一个线程从队列中取出指令执行转账。只有该线程可以访问该银行对象的内部，因此不需要同步。（当然，线程安全的队列类的实现者不能不考虑锁和条件，但是这是他们的问题）

阻塞队列分为以下三类，这取决于当队列满或空时它的响应方式。如果将队列当做线程管理工具来使用，将要用到 put 和 take 方法。当试图向满的队列添加或从空的队列中移除元素时，add、remove、element 操作抛出异常。当然在一个多线程程序中，队列会在任何时候空或满，因此一定要使用 offer、poll、peek 方法作为代替。这些方法如果不能完成任务，只是给出一个错误提示而不是抛出异常。（还有带超时的 offer 和 poll 变体）

`java.util.concurrent`提供了阻塞队列的几个变种，默认情况下，`LinkedBlockingQueue`的容量是没有上边界的，但是也可以选择指定最大容量，它是一个双端的版本。`ArrayBlockingQueue`在构造时需要指定容量并有一个可选参数来指定是否需要公平性，如果设置了公平性则等待时间最长的线程会优先得到处理。通常公平会降低性能，只有在确实非常需要时才使用。`PriorityBlockingQueue`是一个带优先级的队列，而不是先进先出队列。元素按照它们的优先级顺序被移出，该队列没有容量上限。但是如果队列是空的，那么取元素的操作会阻塞。`DelayQueue`包含实现`Delay`接口的对象。

java se7 增加了一个`Transfer`接口，允许生产者等待，直到消费者准备就绪可以增加一个元素。如果生产者调用`q.transfer(item)`，这个调用会阻塞，知道另一个线程将`item`删除，

## 线程安全的集合

如果多线程要并发地访问一个数据结构，如散列表，那么很容易会破坏这个数据结构。可以通过提供锁来保护共享数据结构，但是选择线程安全的实现作为替代可能更容易些，当然，阻塞队列就是线程安全的集合。

### 高效的映射、集、队列

Java 提供了一些有关映射、有序集、队列的高效实现：`ConcurrentHashMap`、`ConcurrentSkipListMap`、`ConcurrentSkipListSet`、`ConcurrentLinkedQueue`

这些集合使用复杂的算法，通过允许并发地访问数据结构的不同部分来使得竞争极小化。
