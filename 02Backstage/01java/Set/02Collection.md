# Collection

## 链表

数组和数组列表(`ArrayList`)都有一个重大缺陷，就是从数组的中间位置删除一个元素要付出很大的代价，其原因是数组中处于被删除元素之后的所有元素都要向数组的前端移动，在数组中间插入一个元素也是如此。

**链表**则解决了该问题。Java 中所有链表实际上都是**双向链接**的，即每个节点还存放着指向前驱节点的引用。

Java 提供了`LinkedList`。

### 注意

链表和泛型集合之间有一个重要的区别，链表是一个**有序集合**(ordered collection)，每个对象的位置十分重要，`LinkedList.add`方法将对象添加到链表的尾部。但是常常需要将元素添加到链表的中间，由于迭代器是描述集合中位置的，所以这种依赖于位置的 add 方法将由迭代器负责，对于自然有序的集合使用迭代器添加元素才有实际意义，如 set 类型，其中的元素完全无序，因此在`Iterator`中就没有`add`方法，相反地，集合类库提供了子接口`ListIterator`，其中包含 add 方法，与`Collection.add`方法不同，该方法不返回`boolean`类型数据而是假定操作总会改变链表。另外`ListIterator`有两个方法用来反向遍历链表：`previous`和`hasPrevious`.`add`方法在迭代器位置之前添加一个新对象。

可以想象如果在某个迭代器修改集合时，另一个迭代器对其进行遍历，一定会出现混乱的状况。如一个迭代器指向另一个迭代器刚刚删除的元素前面，现在这个迭代器就是无效的，并且不应该再被使用。链表迭代器的设计使得它能够检测到这种修改，如果迭代器发现它的集合被修改了，就会抛出一个`ConcureentModificationException`异常。

为了避免并发修改的异常，请遵循这个简单规则：**可以根据需要给容器附加许多的迭代器，但是这些迭代器只能读取列表，另外，在单独附加一个既能读取又能写的迭代器**

另外，链表不支持快速地随机访问。如果要查看链表中的第 n 个元素，就必须从头开始，没有捷径可走，鉴于这个原因，在程序需要采用整数索引访问元素时通常不选用链表。尽管如此，`LinkedList`类还是提供了一个用来访问某个特定元素的`get`方法：`list.get(n)`。当然这个分昂发的效率并不高。

当然如果链表中只有很少几个元素，就完全没有必要为 get 和 set 方法的开销烦恼。使用链表的唯一理由是尽可能减少在列表中间插入或删除元素所付出的代价，如果列表只有少数几个元素，就完全可以使用`ArrayList`

建议如果需要对集合进行随机访问就使用数组或者`ArrayList`。

## 数组列表
`List`元素用于描述一个有序集合，并且集合中的每个元素的位置十分重要。有两种访问元素的协议，一种是用迭代器，另一种是用`get`和`set`方法随机地访问元素，后者不适用于链表，但是对数组很有用。集合类库提供乐`ArrayList`，其封装了一个动态再分配的对象数组。

对比`Vector`，`Vector`所有方法都是同步的，可以由两个线程安全地访问一个`Vector`独享，但是如果由一个线程访问`Vector`代码要在同步操作上耗费大量的时间，所以在不需要同步时使用`ArrayList`

## 散列集

链表和数组按照人们的意愿排列元素的次序，但是如果想要查看某个指定的元素却又忘记了它的位置，就需要访问所有元素直到找到位置。如果集合中包含的元素很多，将会消耗很多时间，如果不在意元素的顺序，可以有几种能够快速查找元素的数据接口，其缺点是无法控制元素出现的顺序，它们将按照其操作目的原则组织数据。

一种众所周知的数据即可欧，可以快速查找所需要的对象，这就是**散列表**（hashtable），散列表为每个对象计算一个整数，称为**散列码**，散列码是由对象实例域产生的一个整数，更准确地说，具有不用数据域的对象将产生不同的散列码。需要注意实现`hashCode()`时要与`equals`方法对应。

在 Java 中，散列表用链表数组实现，每个列表被称为**桶**(bucket)，**要想查找表中对象的位置，就要先计算它的散列码，然后与桶的总数取余，所得到的结果就是保存这个元素的桶的索引**。如，某个对象散列码为 76268，并且有 128 个桶，对象应该保存在第 108 号桶中(76268%128)。或许很幸运，这个同种没有其他元素，此时将元素直接插入到桶中就可以了。当然有时候会遇到桶被占满的情况，这也是不可避免的，这种现象称为**散列冲突**，这时候需要用新对象与桶中的所有对象进行比较，查看这个对象是否已经存在，如果散列码是合理且随机分布的，桶的数目也足够大，只需要比较的次数就会很少。

【注意】Java8 中，桶满时会从链表变为平衡二叉树，如果选择的散列函数不当，会产生很多冲突。

如果想更多的控制散列表的运行性能，就要指定一个初始的桶数，桶数是指用于手机具有相同散列值的桶的数目，如果要插入到散列表中的元素太多，就会增加冲突的可能性，降低运行性能。

如果大致知道最终会有多少个元素要插入到散列表中，就可以设置桶数。

当然并不能总是知道需要存储多少个元素的，也有可能最初的估计过低，如果散列表太满就需要**再散列**(rehashed)，如果要对散列表再散列就需要创建一个桶数更多的表，并将所有的元素插入到这个新表中，然后丢弃原来的表。**装填因子**决定何时对散列表进行再散列，例如如果装填因子为 0.75（默认），而表中超过 75% 的位置已经填入元素这个表就会用双倍的桶数自动地进行再散列，对于大多数应用程序来说，装填因子为 0.75 是合理的。

散列表可以用来实现几个重要的数据结构，其中最简单的是`set`类型，`set`是没有重复元素的元素集合，`set`的`add`方法首先在集中查找要添加的对象，如果不存在就将这个对象添加进去。

### HashSet

Java 集合类库提供了一个 `HashSet`类，其实现了基于散列表的集。可以用`add`方法添加元素，`contains`方法被重新定义，用来快速查看某个元素是否已经出现在集中，它只在某个桶中查找元素，而不必查看集合中所有的元素。

散列集迭代器将依次访问所有的桶，由于散列将元素分散在表的各个位置上，所以访问它们的顺序几乎是随机的，只有不关心集合中元素的顺序时才使用`HashSet`

## TreeSet

`TreeSet`与散列集十分相似，不过它比散列集有所改进，树集是一个**有序集合**，可以以任意顺序将元素插入到集合中，在对集合进行遍历时，每个值将自动地按照排序后的顺序呈现。【要使用树集必须，元素必须要实现 `Comparable` 接口】

其内部的排序是按照树结构完成的（当前使用的是红黑树），每次将一个元素添加到树中时，都被放置在正确的排序位置上。因此迭代器总是以排序号的顺序访问每个元素。

将一个元素添加到树中要比添加到散列表中慢，但是与检查数组或链表中的重复元素相比还是快很多，如果树中包含了 n 个元素，那么查找新元素的正确位置平均需要log<sub>2</sub>n

如果不需要对数据进行排序，就没有必须要付出排序的开销，更重要的是，对于某些数据来说，对其排序要比散列函数更加困难，散列函数只是将对象适当打乱存放，而比较要精确判别每个对象。想要具体了解它们之间的差异还要研究一个收集矩形集的任务。如果使用`TreeSet`就要提供`Comparator<Rectangle>`，如何比较两个矩形呢？树的排序必须是全序，也就是说任意两个元素必须是可比的，并且只有在两个元素相等时结果才为 0，确实有一种方式但是十分繁琐。

## 队列与两端队列

队列可以让人们有效地在尾部添加一个元素 在头部删除一个元素。有两个端头的队列，即**双端队列**，可以让人们有效地在头部和尾部同时添加或删除元素，不支持在队列中间添加元素。
java se6 中引入了`Deque`接口并由`ArrayDeque`和`LinkedList`类实现，这两个类都提供了双端队列。而且在必要时可以增加队列的长度。

`Queue`中的几个方法：
- `boolean add(E element)`,`boolean offer(E element)`，如果队列没有满则将给定的元素添加到这个双端队列的尾部并且返回 true，如果满了，第一个方法抛出异常，而第二个方法返回 false
- `E remove()`，`E poll()`，如果队列不为空，删除并返回这个队列头部的元素，如果队列是空的，第一个方法抛出异常而第二个返回 null
- `E element()`，`E peek()`，如果队列不空，返回这个队列头部的元素，但不删除。如果队列为空，第一个方法抛出异常而第二个返回 null

## 优先级队列

优先级队列`priority queue`中的元素可以按照任意的顺序插入，却总是按照排序的顺序进行检索，也就是说无论何时调用 remove 方法总是会获得当前优先级队列中的最小的元素。然而优先级队列并没有对所有的元素进行排序，如果用迭代的方式处理这些元素并不需要对它们进行排序。优先级队列使用了一个优雅且高效的数据结构：**堆**，堆是一个可以自我调整的二叉树，对树进行添加或删除操作可以让最小的元素移动到根，而不必花费时间排序。

与 `TreeSet`一样，一个优先级队列既可以保存实现了`Comparable`接口的对象也可以保存在构造器中提供的`Comparator`对象。

使用优先级队列的典型示例是任务调度，每个任务有一个优先级，任务以随机顺序添加到队列中。每当启动一个新的队列时，都将优先级最高的任务从队列中删除。（习惯将 1 设置为最高优先级）


