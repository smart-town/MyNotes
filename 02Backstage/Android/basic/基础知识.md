# Android 应用基础知识
- Android 系统是一种多用户 Linux 系统，其中的每个应用都是一个不同的用户
- 默认情况下，系统会为每个应用分配一个唯一的 Linux 用户 ID，其仅由系统使用。系统会为应用中所有文件设置权限，使得只有分配给该应用的用户 ID 才能访问这些文件
- 每个进程都拥有自己的虚拟机(VM)，因此用户代码独立于其他应用而运行
- 默认情况下，每个应用都在自己的 linux 进程内运行，Android 系统会根据需要执行任何应用组件时启动该进程，然后当不再需要该进程时或系统必须为其他应用恢复内存的时候，其便会关闭该进程

Android 系统实现了最小权限原则，即默认每个应用只能访问执行其工作所需的组件，而不能访问其他组件。这样便能创建非常安全的环境，在此环境中，应用无法访问其未获得权限的部分。不过应用仍然可以通过一些途径与其他应用共享数据以及访问系统服务：
- 可以安排两个应用共享同一个 Linux 用户 ID，在此情况下二者便能访问彼此文件。为了节省系统资源，也可以安排拥有相同用户 ID 的应用在同一个 Linux 进程中运行，并共享同一 VM，应用还必须使用相同的证书签名
- 应用可以请求访问设备数据，如用户联系人、短信消息等。

1. 定义应用的核心框架组件
2. 声明组件和应用必需设备功能的清单文件
3. 与应用代码分离并允许应用针对各种设备配置适当优化其行为的资源

## 1. 应用组件
应用组件是 Android 应用的基本构建块。每个组件都是一个入口点，系统或用户可以通过该入口点进入你的应用。有些组件会依赖于其他组件：
- Activity
- 服务
- 广播接收器
- 内容提供程序

每种类型都有不同的用户和生命周期，后者会定义如何创建和销毁组件。应用组件的四种类型。
### Activity
`Activity`是与用户交互的入口点，它表示拥有界面的单个屏幕。如电子邮件应用可能有一个显示新邮件列表的`Activity`，一个用于撰写电子邮件的`Activity`等，尽管这些`Activity`通过协作在电子邮件应用中形成一种紧密结合的用户体验，但是每个`Activity`都独立于其他`Activity`存在。因此其他应用可以启动其中任何一个`Activity`（如果电子邮件应用允许）。`Activity`有助于完成系统和应用程序之间的以下重要交互：
- 追踪用户当前关心的内容（屏幕上显示的内容），以确保系统继续运行托管`Activity`的进程
- 了解先前使用的进程包含用户可能返回的内容（已停止的`Activity`），从而更优先保留这些进程
- 帮助应用处理终止其进程情况，以便用户可以返回已经恢复先前状态的`Activity`
- 提供一种途径，让应用实现彼此之间的用户流，并让系统协调这些流

你需要将`Activity`作为`Activity`类的子类来实现
### 服务
服务是一个通用入口点，用于因为各种原因使得应用在后台保持运行状态。它是一种在后台运行的组件，用户执行长时间运行的操作或者为远程进程执行作业。服务不提供界面。例如，当用户使用其他应用时，服务可能在后台播放音乐或者通过网络获取数据，但是这不会阻断用户与`Activity`的交互。诸如`Activity`等其他组件可以启动服务，使得服务运行或绑定到服务，以便与其进行交互。事实上有两种截然不同的语义服务可以告知系统如何管理应用：已启动服务会告知系统使其运行至工作完毕。此类工作可以是在后台同步一些数据，或者在用户离开应用之后继续播放音乐，在后台同步数据或者播放音乐代表两种不同类型的已启动服务，而这些服务可以修改系统处理他们的方式：
- 音乐播放是用户可以感知的服务。因此，应用会向用户发送通知，表明其希望成为前台，从而告诉系统此消息；在此情况下，系统明白它应该维持该服务运行，因为进程消失会令用户感到不快
- 通常，用户不会意识到常规后台服务正处于运行状态，因此系统可以更自由地管理其进程。如果系统需要使用 RAM 来处理用户更迫切关注的内容，则其可能允许种植服务（然后在稍后的某个时刻重启服务）

绑定服务之所以能够运行，原因是某些其他应用或者系统表示希望使用该服务，从根本上讲，这是为另一个进程提供 API 的服务。因此系统会知晓这些进程之间存在依赖甚。所以如果进程 A 绑定到进程 B 的服务，系统便知道自己需要使用进程 B 及其服务为进程 A 保持运行装填。此外，如果进程 A 是用户关心的内容，系统随即也知道将进程 B 视为用户关心的内容。由于存在灵活性，服务已经成为非常有用的构建块，并且可以实现各种高级系统概念。动态壁纸、屏幕保护程序、输入方法等众多核心功能均可以构建为在其运行时由应用实现、系统绑定的服务

你需要将服务作为`Service`的子类来实现。
**注意** 如果在 Android 5.0 或更高版本，使用`JobScheduler`来调度操作。
### 广播接收器
借助广播接收器组件，系统能够在常规用户流之外向外传递事件，从而允许应用响应系统范围内的广播通知。由于广播接收器是另一个明确定义的应用入口，因此系统甚至可以向当前未运行的应用传递广播。例如应用可以通过调度提醒来发布通知，以告诉用户即将发生的事情。而且通过将该提醒传递给应用的广播接收器，应用在提醒响起之前无需继续运行。许多广播均由系统发起，如通知屏幕已经关闭、电池电量不足等。应用也可以发起广播，如通知其他应用某些数据已经下载到设备。尽管广播接收器不会显示界面，但是**可以创建状态栏通知**，在发生广播事件时提醒用户。但是广播接收器更常见的用途只是作为通向其他组件的通道，旨在执行极少量的工作

广播接收器作为`BroadCaseReceiver`子类实现，并且每条广播都作为`Intent`对象进行传递
### 内容提供程序
内容提供程序管理一组共享的应用数据，你可以将这些数据存储在文件系统里、`SQLite`数据库、网络中或者你的应用可以访问的任何其他持久化存储位置。其他应用可以通过内容提供程序查询或者修改数据（如果内容提供程序允许），例如 Android 可以提供管理用户联系人信息的内容提供程序，因此任何拥有适当权限的应用均可查询内容提供程序，以读取和写入特定人员的相关信息。我们可以很容易将内容提供程序看作数据库上的抽象，因为其内置的大量 API 和支持时常适用于这一情况。但是从系统设计的角度看，二者的核心目的不同。对于系统而言，内容提供程序是应用的入口点，用户发布由 URI 架构识别的已命名数据项，因此应用可以决定如何将其包含的数据映射到 URI 名命空间，进而将这些 URI 分发给其他实体。反之，这些实体也可以使用分发的 URI 来访问数据。

内容提供程序也适用于读取和写入你应用不共享的私有数据

内容提供程序作为`ContentProvider`的子类实现，且必须实现一组标准 API，以便其他应用能够执行事务。

Android 系统设计的独特之处在于，任何应用都可以启动其他应用的组件，例如当你想要用户使用设备相机拍摄照片，另一个应用可能也可以执行该操作，因而你的应用便可以使用改应用，而非自行产生一个`Activity`来拍摄照片。

当系统启动某个组件时，它会启动该应用的进程（如果尚未运行），并实例化该组件所需要的类。例如，如果你的应用启动相机应用中拍摄照片的`Activity`，则其会在属于相机应用中的进程中运行。因此与大多数其他系统上的应用不同，Android 并没有单个入口点（即`main`函数）

由于系统在单独的进程中运行每个应用，且其文件权限会限制对其他应用的访问，因此你的应用无法直接启动其他应用中的组件，但是 Android 可以。如果要启动其他应用中的组件，请向系统传递一条消息，说明启动特定组件的`Intent`。

### 启动组件
四种组件类型中，三种(Activity、服务和广播接收器)均通过异步消息`Intent`进行启动，`Intent`会在运行时对各个组件进行相互绑定，你可以将`Intent`视为从其他组件请求操作的信使。

你需要使用`Intent`对象创建`Intent`，该对象通过定义消息来启动特定组件（显式 Intent）或特定的组件类型（隐式 Intent）。

对于 Activity 和服务，`Intent`会定义要执行的操作（如查看或发送某内容），并且可以指定待操作数据的 URI，以及正在启动的组件可能需要了解的信息。例如 Intent 可能会传达对 Activity 的请求，以便显示图像或打开网页。某些情况下，你可以通过启动 Activity 来接收结果，这样 Activity 还会返回 Intent 中的结果。如你可以发出一个`Intent`让用户选渠某位联系人并将其返回给你。

对于广播接收器，`Intent`只会定义待广播的通知。

与其他三个组件不同，内容提供程序，内容提供程序并非由`Intent`启动，其会在成为`ContentResolver`的请求目标时启动。内容解析程序会通过内容提供程序处理所有直接事务，因此通过提供程序执行事务的组件便无需执行事务，而是改为在`ContentResolver`对象上调用方法。

每种组件都有不同的启动方法：
- `Activity`，可以向`startActivity()`或`startActivityForResult()`传递`Intent`
- Android5 或更高版本(API 21)，你可以使用`JobScheduler`来调度操作，对于早期版本，你可以通过向`startService()`传递`Intent`来启动服务（或对执行中的服务下达新指令），你也可以通过向`bindService()`传递`Intent`来绑定到该服务
- 你可以通过向`sendBroadcast`、`setOrderedBroadcase()`或其他方法传递`Intent`来发起广播
- 可以通过在`ContentResolver`上调用`query()`，对内容提供程序执行查询

## 清单文件
Android 系统启动应用组件之前，系统必须通过读取应用清单文件`AndroidManifest.xml`来确认组件存在，你的应用必须在此文件中声明其所有组件，该文件必须位于应用项目录的根目录中。

除了声明应用的组件外，清单文件还有许多其他作用：
- 确定应用所需要的任何用户权限（如互联网访问权限）
- 根据应用使用的 API，声明应用所需的最低 API 级别
- 声明应用使用或需要的软件和硬件功能，如相机、蓝牙服务、多点触摸屏幕
- 声明应用所需要链接的 API 库（Android 框架 API 除外）

### 声明组件
如清单文件声明 Activity:
```xml
<mainfest ...>
    <application android:icon="..." ...>
        <activity android:name="com.example.project.ExampleActivity" ...>
        </activity>
    </application>
</mainfest>
```
你必须使用以下元素声明所有应用组件：
- `<activity>` 
- `<service>` 服务元素
- `<receiver>` 广播接收器
- `<provider>` 内容提供者
如果未在清单中声明源代码中包含的 Activity、服务和内容提供程序，则这些组件对系统不可见，因此也永远不会运行。不过你可以`BroadcastReceiver`对象的形式，在清单中声明或在代码中动态创建广播接收器，以及调用`registerReceiver()`在系统中注册广播接收器
### 声明组件功能
使用`Intent`来启动组件，你可以通过在`Intent`中显式命名目标组件（使用组件类名）来使用，也可以借助隐式`Intent`，通过它来描述要执行的操作类型和待操作数据。借助隐式`Intent`，系统能够在设备上找到可执行该操作的额组件，并启动该组件，如果有多个组件可以执行`Intent`所描述的操作，则由用户选择使用哪一个组件。

通过将接收到的`Intent`与设备上其他应用的清单文件中提供的`Intent`过滤器进行比较，系统就可以识别能响应`Intent`的组件。

在应用的清单文件中声明`Activity`时，可以选择性加入`Activity`功能的`Intent`过滤器，以便响应来自其他应用的`Intent`：
```xml
<activity android:name="com.example.porject.CompseEmail">
    <intent-filter>
        <action android:name="..."/>
        <data android:type="*/*"/>
        <category android:name="..."/>
    </intent-filter>
</activity>
```
### 声明应用要求
Android 设备多种多样，但是并非所有设备都提供相同的特性和功能，以防止将你的应用安装在缺少应用所需特性的设备上，你必须通过在清单文件中声明设备和软件要求，为该应用支持的设备类型明确定义一个配置文件。其中大多数声明只是为了提供信息，系统并不会读取它们，但 Google Play 等外部服务会读取它们，以便用户通过其设备搜索应用时为用户提供过滤功能。 如：
```xml
<mainfest ...>
    <use-feature android:name="android.hardware.camera.any" android:required="true"/>
    <use-sdk android:minSdkVersion="7" android:targetSdkVersion="19"/>
</mainfest>
```
通过示例中的声明，没有相机且 Android 版本低于 2.1 的设备将无法从 Google Play 安装你的应用。不过你可以声明你应用使用相机，但是不要求必须使用。

## 应用资源

Android 应用并非仅仅包含代码，还需要与源代码分离的资源，如图像、音频文件以及任何与视觉呈现相关的内容。你可以借助 XML 文件定义`Activity`界面的动画、菜单、样式、颜色和布局。借助应用资源，你无需修改代码即可轻松更新应用的各种特性。通过提供备用资源集，你可以针对各种设备配置（如不同的语言和屏幕尺寸）优化你的引用

对于你在 Android 设备中加入的每一项资源，SDK 工具均会定义唯一的整型 ID，你可以利用此 ID 引用资源，这些资源或来自应用代码，或来自 XML 中定义的其他资源。如，假设你应用中包含名为`logo.png`图像文件，保存在`res/drawable/`中，则 SDK 会生成名为`R.drawable.logo`的资源 ID，此资源 ID 映射到应用特定的整型数。

如果提供与源代码分离的资源，其中重要一个优点在于，你可以提供适用于不同设备配置的备用资源。

Android 支持许多不同的备用资源限定符。限定符是资源目录名称中加入的短字符串，用于定义这些资源适用的设备配置。