# 进程和线程

今天我们所使用的计算机早就已经进入了多 CPU 或者说多核时代，而我们使用的操作系统都是支持“多任务”的操作系统，这使得我们可以同时运行多个程序，也可以将一个程序分解为若干个相对独立的子任务，让多个子任务并发地执行，从而缩短程序的执行时间，同时也让用户获得更好的体验。因此在当下不管是用什么编程语言开发，实现让程序同时执行多个任务也就是常说的“并发编程”，应该是程序员必备技能之一。为此需要先讨论两个概念，进程和线程

## 1. 概念

**进程**就是操作系统中执行的一个程序，操作系统以进程为单位分配存储空间，每个进程都有自己的地址空间、数据栈以及其他用于追踪进程执行的辅助数据，操作系统管理所有进程的执行，为它们合理地分配资源。进程可以通过`fork`或`spawn`的方式来创建新的进程来执行其他的任务，不过新的进程也有自己独立的内存空间，因此必须通过进程间通信机制(IPC, Inter Progress Communication)来实现数据共享，具体的方式包括管道、信号、套接字、共享内存区等。

一个进程还可以有多个并发的执行线索，简单来说就是拥有多个可以获得 CPU 调度的执行单元，这就是所谓的线程。由于线程在同一个进程下，它们可以共享相同的上下文，因此相对于进程来说，线程间的信息共享和通信都更为容易。当然在单核 CPU 下，真正的并发是不可能的，因为在某个时刻能够获得 CPU 的只有唯一的一个线程，多个线程共享了 CPU 的执行时间。使用多线程实现并发编程为程序带来的好处是不言而喻的，最主要的体现在于提升程序的性能和改善用户体验，今天我们使用的软件几乎都用到了多线程技术。

当然多线程也并不是没有坏处，站在其他进程的角度，多线程的程序对其他程序并不友好，因为它占用了更多的 CPU 执行时间，导致其他程序无法获得足够的 CPU 执行时间。另一方面，站在开发者的角度，编写和调试多线程的程序都对开发者有较高的要求，对于初学者来说更难。

Python 即支持多进程又支持都线程，因此使用 Python 实现并发编程主要有 3 种方式：多进程、多线程、多进程+多线程

## 2. Python 中的多进程

Unix 和 Linux 操作系统中提供了`fork()`系统调用来创建进程，调用`fork()`函数的是父进程，创建出的是子进程，子进程是父进程的一个拷贝，但是子进程拥有自己的 PID。`fork()`函数非常特殊，它会返回两次，父进程可以通过`fork()`函数返回值得到子进程的 PID，而子进程中的返回值永远都是 0. Python 的 os 模块提供了`fork()`函数，由于 Windows 中没有`fork()`调用，因此要实现跨平台的多进程编程，可以使用`multiprocessing`模块的`Process`类来创建子进程，而且该模块还提供了更高级的封装，例如批量启动进程的进程池(`Pool`)、用于进程间通信的队列`Queue`、管道`Pipe`等

[例子](../00Test/Basic/Process.py)

### 多个进程之间的通信
```py
from multprocessing import Process
from time import sleep

counter = 0

def sub_task(string):
    global counter
    while counter < 10:
        print(string, end='', flush=True)
        counter += 1
        sleep(0.01)

def main():
    Process(target=sub_task, args=('Ping',)).start()
    Process(target=sub_task, args=('Pong',)).start()
```

当我们在程序中创建进程的时候，子进程复制了父进程及其所有数据结构，每个子进程有自己独立的内存空间，这也就意味着两个子进程各有一个`counter`变量，所以结果可想而知。

可以使用`multiprocessing`模块中的`Queue`类，它是可以被多个进程共享的队列，底层是通过管道和信号量机制来实现的。

## 2. Python 中的多线程

在 Python 中的早期就引入了`thread`模块（现在名为`_thread`）来实现多线程编程，然而该模块过于底层，而且很多功能都没有提供，因此目前的多线程开发我们推荐使用`threading`模块，该模块对多线程提供了更好的面向对象的封装：
[例子](../00Test/Basic/Thread.py)

我们可以直接使用`threading`模块中的 `Thread`类来创建线程，也可以通过继承`Thread`类的方式来创建自定义的线程类，然后再创建线程对象并启动线程。