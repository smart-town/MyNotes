# 模块

开发过程中代码越写越多，一个文件中的代码越来越长，也就会越来越不容易维护。

为了编写可以维护的代码我们将很多函数分组，分别放到不同的文件中。这样每一个文件包含的代码就相对变少，很多编程语言都采用这样的编程方式。在Node环境中，一个.js文件就被称为一个模块。

这样做的好处在于大大提高了代码的可维护性，其次编写代码不必从零开始。当一个模块编写完毕就可以被其他地方引用。我们编写程序的时候也经常引用其他模块，包括 Node 内置的模块和来自第三方的模块。使用模块还可以避免函数名和变量名冲突，相同名字的函数和变量完全可以存放在不同的模块中。

如，编写一个`hello.js`文件，这就是一个模块，模块的名字就是`hello`。

```js
//hello.js
'use strict';
var s = "hello" ;
function greet(name){
    console.log(s + ", " + name);
}

module.exports = greet;
```

`greet`函数是我们在`hello`模块中定义的。最后的赋值语句，**将函数`greet`作为模块的输出暴露出去**，这样其他模块就可以使用 `greet` 函数了。

其他模块如何引用？

```JS
//hello2.js
"use strict";
var greet = require("./hello") ;
var s = "Michael";
greet(s) ;
```

注意引入`hello`模块引用的是Node提供的`require`函数。引入的模块作为变量保存在`greet`变量中，`greet`变量就是在`hello.js`中我们用`module.exports=greet`输出的`greet`函数。注意使用`require()`引入模块时的相对路径，如果只写模块名则Node会依次在内置模块、全局模块和当前模块下查找`hello.js`。很可能会得到一个错误。

## CommonJS 规范

这种模块加载机制被称为CommonJS规范，在这个规范下，每个`.js`文件都是一个模块，他们内部各自使用的变量名和函数都互不冲突。一个模块要想对外暴露变量（函数也是变量），可以用`module.exports = variable`，一个模块要引用其他模块暴露的变量，用`var ref = require("module_name")`就拿到了引用模块的变量

### 深入了解模块原理

