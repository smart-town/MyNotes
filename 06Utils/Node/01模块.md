# 模块

## 为什么要？

随着代码越来愈多、越来越长则越来越不容易维护。为了编写可以维护的代码，将函数分组分别放在不同的文件里这样每个文件包含的代码就相对变少，很多编程语言都采用这样的组织代码方式。在Node中一个.js文件就称为一个模块。

历史上，JavaScript一直没有模块体系，无法将一个大程序拆分成为相互依赖的小程序。再用简单的方法拼接起来。其他语言都有这项功能，如 Python 的 `import`。甚至就连 CSS 也有 `@import`,但是 js 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了障碍。

在 ES6 之前，社区制定了一些模块加载方案。最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。ES6 在语言标准的层面上，实现了模块功能，而且实现地非常简单。完全可以取代这两种规范，成为浏览器和服务器通用的模块解决方案。

## CommonJS 规范

该规范下，每个 js 文件都是一个模块，它们内部各自使用的变量名和函数名都不冲突，例如`hello.js`和`main.js`都申明`var x = 'xxx'`但是互不影响。

一个模块要对外暴露变量，可以用`module.exports = variable`，一个模块要引用其他模块暴露的变量，用`var ref = require("moduleName")`，就拿到了引用模块的变量。

## 深入了解模块原理

对于 js 本身来说，申明全局变量 `var s = 'global'`。在浏览器中大量使用全局变量并不好，如果在a.js中用了全局s，那么在b.js中也使用了全局变量s，将会造成冲突，b.js对s的赋值会改变a.js的运行逻辑。也即是说，js语言本身并没有一种模块机制来保证不同模块可以使用相同的变量名。那么Node如何坐到?其实要实现模块这个功能，并不需要语法层面的支持。Node.js也不会增加任何js语法。实现模块的奥妙就在于js是一种函数式编程语言、它支持闭包，如果我们将一段javascript代码用一个函数封装起来，这段代码中的全局变量就会成为函数内部的局部变量。

```js
//hello.js
var s = 'hello' ;
var name = 'world' ;
console.log(s + " " + name) ;

//Node 加载后，可以这样：
(
    function(){
        //读取的hello.js代码
        var s = 'hello' ;
        var name = 'world' ;
        console.log(s + ' ' + name) ;
    }
);
```

这样一来，原来的全局变量 s 现在就变成了局部变量。如果Node继续加载其他模块，这些模块中定义的全局变量s也互不干扰。所以Node利用javascript的函数式编程的特点，轻而易举地实现了模块的隔离。

但是，模块的输出`module.exports`是怎么做的呢？

这也很容易，Node可以事先准备一个对象`module`

```js
var module = {
    id: "Hello",
    exports: {}
} ;
var load = function(module){
    //读取hello.js
    function greet(name){
        console.log("Hello," + name) ;
    }

    module.exports = greet ;
    return module.exports ;
}
var exported = load(module) ;
save(module, exported) ;
```

可见变量`module`是Node在加载js文件前准备的一个变量，并将其传入加载函数。我们在`hello.js`中可以直接使用变量`module`的原因就是它实际是函数的一个参数。`module.exports = greet`。通过把参数传入 load 函数，hello.js 就顺利地把一个变量传递给了Node执行环境，Node会把module变量保存在某个地方。

由于 Node 保存了所有导入的`module`，当我们用`require()`获取module时，Node找到对应的`module`，将这个`module`的`exports`变量返回，这样，另外一个模块就顺利地拿到了模块的输出。`var greet = require("./hello") ;`.

以上是Node实现javascript模块的简单原理介绍。

### module.exports VS expors

很多时候可以看到 Node 中有两种方法在一个模块中输出变量

```js
module.exports = {
    hello: hello,
    greet: greet
}

exports.hello = hello;
exports.greet = greet ;
```

但是不可以直接对`exports`赋值。

分析 Node 的加载机制，首先 Node 会把待加载的 `hello.js` 放入一个包装函数`load`中执行，在执行这个`load`函数之前，Node准备好了module变量：

```js
var module = {
    id: "hello",
    exports: {}
}
```

`load`函数最终返回`module.exports`

```js
var load = function(exports, module){
    //hello.js

    return module.exports ;
} ;

var exported = load(module.exports, module) ; 
```

也就是说，默认情况下，Node准备的`exports`变量和`module.exports`变量实际上是同一个变量，并且初始化为空对象`{}`。于是我们可以写：

```js
exports.foo = function(){return "foo";} ;
exports.bar = function(){...};

或者

module.exports.foo = function()...
module.exports.bar = ...
```

换句话说说，Node默认给了你一个空对象`{}`这样你可以向里面加东西。但是如果我们输出的是一个函数或者数组那么只能用`module.exports`赋值。给`exports`赋值是无效的，因为赋值后，`module.exports`仍然是空对象。

所以如果要输出一个键值对象，可以利用`exports`这个已经存在的空对象，并继续在上面添加新的键值。但是如果要输出一个函数或者数组必须对`module.exports`进行赋值。所以我们可以得到**结论**，直接对`module.exports`赋值可以应对任何情况。

