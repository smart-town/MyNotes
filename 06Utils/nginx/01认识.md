# nginx

[原文](https://www.w3cschool.cn/nginx/sd361pdz.html)

## 认识

NGINX 使用可扩展的事件驱动架构，而不是更传统的过程驱动架构。这需要更低的内存占用并且当并发连接扩大时，使内存使用更可预测。

传统的 web 服务器体系结构中，每个客户端连接作为一个单独的进程或者线程处理，随着网站的流行度增加、并发链接数增加，web 服务器减慢，延迟了对用户的响应。

从技术的角度看，产生一个单独的进程或线程需要 CPU 切换到新的任务并创建一个新的运行时上下文，消耗额外的内存和 CPU 时间，从而对性能产生负面影响。

NGINX 开发的目标是实现 10 倍以上的性能，优化服务器资源的使用，同时也能够扩展和支持网站的动态增长，因此 NGINX 成为最知名的模块化，事件驱动，异步，单线程 web 服务器和 web 代理之一。

- 作为 web 服务器
- 作为负载均衡服务器
- 作为邮件代理服务器

## 认识 nginx 架构

Nginx 的高性能和其架构是分不开的。

Nginx 在启动后，在 unix 系统中会以 daemon 方式在后台运行，后台进程包括一个 master 进程和多个 worker 进程，也可以手动关闭后台模式让其在前台运行，并且通过配置让 Nginx 取消 master 进程从而让其以单进程方式运行。很显然生产环境下不会这样做，关闭后台模式一般是用来调试用的。可以看到 Nginx 是以多进程方式来工作的，当然其也是支持多线程方式的，只是主流的方式还是多进程的方式，也是 Nginx 的默认方式。

Nginx 启动后，master 进程主要用来管理 worker 进程，包含：接收来自外界的信号，向各个 worker 发送信号，监控 worker 进程运行状态。当 worker 异常退出后，会自动重新启动新的 worker 进程。而基本的网络事件则是放在 worker 中处理了，多个 worker 进程之间是对等的，他们同等竞争来自客户端的请求，各进程之间是独立的，一个请求只可能在一个 worker 进程中处理，一个worker进程不可能处理其他进程的请求。worker 进程的个数是可以设置的，一般会设置为与机器 cpu 核数一致，这里面的原因与 Nginx 进程模型以及事件处理模型是分不开的。

在 Nginx 启动后，如果要操作 nginx 该怎样做呢？可以了解到，master 来管理 worker，所以只需要与 master 通信就可以了。master 会接收来自外界的信号，再根据信号做不同的事情，所以要控制 nginx 只需要通过`kill`向 master 进程发送消息就可以了。如`kill -HUP pid`则是从容重启 nginx，因为是从容所以服务是不中断的。。。其是如何操作呢？接收到信号后，master 先重新加载配置文件，然后再启动新的 worker 进程，并向所有老的 worker 进程发送信号告诉其可以退休了，新的 worker 启动后，就开始接收新的请求，而老的 worker 在收到来自 master 的信号后，就不再接收新的请求，并且在当前进程中的所有未处理完的请求处理完成后再退出。 Nginx 在 0.8 版本后引入了一系列命令行参数来方便管理，如`nginx -s reload`就是重启 Nginx。如何做到呢？执行命令时就是启动一个新的 nginx 进程其检查参数，并解析，然后向 master 发送信号就可以了。。。

worker 又是如何处理请求呢？worker 进程之间是平等的，每个进程处理请求的机会也是一样的，当我们提供 80 端口的 http 服务时，一个连接请求过来每个进程都可能处理这个连接，如何做到？每个 worker 都是从 master fork 过来的，在 master 进程中先建立好需要 listen 的 socket(listenfd) 之后，然后再 fork 出多个进程，所有 worker 进程的 listenfd  会在新连接到来时变得可读，为保证只有一个进程处理对应请求则使用到了锁机制。。

这种进程模型带来的好处显而易见：独立的进程无需加锁省掉了锁带来的开销，其次一个进程退出后其他进程还在工作服务不会中断，就算 worker 异常退出也不会影响到所有的请求。

然而，每个 worker 只有一个主线程，又是如何处理并发的呢？nginx 采用了**异步非阻塞**方式来处理请求，其可以同时处理成千上万个请求，但是 apache 的常用工作方式（apache 也有异步非阻塞版本不过不常用），每个请求会独占一个工作线程，当并发数到上千时，就同时有几千个线程在处理请求了，这对于操作系统来说是一个不小的挑战，线程带来的内存占用非常大，上下文切换带来的 CPU 开销也很大。



