# 数据流重导向

## 是什么

执行一个命令时，这个指令可能由文件读入数据，经过处理后再输出到屏幕。默认有`standard output`和`standard error`,其都是输出到屏幕上。

标准输出指的是“指令执行所传回的正确信息”，而标准错误“指令执行失败后传回的信息”。不管正确还是错误的数据都默认输出到屏幕上。**数据流重导向**可以将`stdout`和`stderr`分别传送到其他文件或设备中，而分别传送所用的特殊字符如下：
- 标准输入(stdin)，代码为`0`,使用`<`或`<<`
- 标准输出(stdout),代码为`1`，使用`>`或`>>`
- 标准错误(stderr)，代码为`2`,使用`2>`或`2>>`
### 标准输出和标准错误
`>`会清空并写入文件，而`>>`则是附加。如：`ls > /test`

将错误与正确信息分开存放：`find /home name .bashrc >list_right 2>list_error`

将指令的错误和正确信息输出到同一个文件：`find /home -name . .bashrc >list 2>&1`
### 标准输入
而`stdinput`则是“将原本需要从键盘输入的数据，改由文件内容来代替”。如，使用`cat >test`可以创建内容到test文件中，而键盘输入的数据可以由文本文件代替键盘输入：`cat >test <test.ts`。

而`<<`则是“结束的输入字符”，如`cat >test <<"efo"`，此时可以通过键盘输入内容，最后输入`eof`即可退出 cat ，而不需要使用`ctrl+d`来退出。

### 为什么使用重导向呢

- 屏幕输出的信息很重要需要保存时
- 背景执行中的程序，不希望它干扰正常的输出结果时
- 错误讯息和正确信息需要分别输出
- ...

### /dev/null

黑洞设备。该`/dev/null`可以吃掉任何导向这个设备的信息。将错误信息丢弃时，如：`find /home 2>/dev/null`此时就不会有错误信息输出。

## 命令执行判断依据

某些情况下可能需要一次输入执行多条命令，基本上有两种选择：shell脚本或一次输入多条指令

### cmd;cmd
不考虑指令相关性时，连续下达指令。在指令和指令之间用分号隔开，这样一来，分号之前的指令执行完后就会立刻接着执行后面的指令了。

### `$?` 与 `&&` `||`

当两个指令具有相关性时，该相关性主要判断的地方在前一个指令的正确执行与否。在 Linux 下，如果前一个指令执行正确，会回传一个`$? = 0`的值。如何根据该回传值来判断后续的指令是否需要修改呢？就要借助`&&`和`||`的帮忙了。
- `cmd1 && cmd2`： 如果 cmd1 执行完毕且正确时才执行 cmd2
- `cmd1 || cmd2`: cmd1 执行正确，则 cmd2 执行，否则不执行

一般来说`comand1 || comand2 && comand3`这种形式较为常用，如创建`/abc/test`文件，先判断有无`/abc`文件夹，没有则创建对应文件夹，有则创建文件，`ls /abc || mkdir /abc && touch /abc/test`

