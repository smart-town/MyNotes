# Linux 进程

计算机实际上能做的事情十分简单，如计算和、找到某个地址。最基础的计算机动作被称为**指令**，所谓**程序**就是这些指令的集合。通过程序我们可以让计算机完成复杂的工作。程序大多数被存储为可执行的文件。这样一个可执行文件就好像菜谱，计算机按照菜谱做出饭菜。

当计算机开始执行某个可执行文件时，**程序**就成为了**进程**。

可以使用`ps`查询正在运行的进程。如`ps -eo pid,comm,cmd`。每个进程都有一个PID代表自己的身份。COMMAND是进程的简称。CMD是进程所对应的程序以及运行时所带的参数。CMD中有一些用中括号括起来的，它们是内核的一部分功能，被打扮成进程的样子以方便操作系统管理。

## 如何创建一个进程

实际上计算机开机时，内核只建立了一个进程`init`。Linux内核并不提供直接建立新进程的系统调用。剩下的所有进程都是由`init`进程通过`fork`机制建立的。新的进程要通过老的进程**复制自身**得到。这就是`fork`。fork是系统调用，进程存活于内存中。每个进程都在内存中分配有属于自己的一片空间，当进程`fork`的时候，Linux在内存中开辟出一片新的内存空间给新的进程，并将老的进程空间中的内容复制到新的空间中。此后两个进程同时运行。

## 子进程的终结

当子进程终结时，它会通知父进程，并清空自己占据的内存，且会在内核中留下自己的**退出信息**(exit code，如果顺利运行，为0；如果有错误或者异常状况为>0的整数)。在这个信息中会解释进程为什么会退出。父进程在得知子进程退出时，有责任对该子进程使用**wait**调用，这个wait函数能够从**内核中取出子进程的退出信息**，并清空该信息在内核中所占据的空间。但是如果父进程早于子进程终结，子进程就会成为一个**孤儿**进程，孤儿进程会进而被过继给`init`进程，此时init进程负责在子进程终结的时候调用wait函数。

当然一个糟糕的程序可能造成子进程的**退出信息滞留在内核**中的状况（父进程不对子进程调用wait函数），这样的情况下，子进程成为**僵尸进程**。当大量的僵尸进程累积时，内存空间会被挤占。

## 进程与线程

尽管在 UNIX 中进程和线程是有联系但是不同的两个东西，但是在Linux中，线程只是一种特殊的进程。多个线程之间可以共享内存空间和IO接口，所以进程是Linxu程序的唯一实现方式。