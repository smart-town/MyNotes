# 进程关系

Linux 的进程之间相互之间有一定的关系，比如说在进程基础中可以看到每个进程都有父进程，而所有的父进程都以init进程为根，形成一个树状结构。

## 进程组

每个进程都属于一个进程组(process group)，每个进程组中可以包含多个进程，进程组会有一个**进程组领导进程**，领导进程的PID成为进程组的ID，以识别进程组。我们将一些进程归为进程组的一个重要原因是我们可以将信号发送给一个进程组，进程组中的所有进程都会收到该信号。

## 会话

更进一步，在shell支持工作控制的前提下，多个进程组还可以构成**会话**，bash支持工作控制而sh并不支持

会话是由其中的进程建立的，该进程叫做会话的领导进程。会话领导进程的PID成为识别会话的SID(session id)。绘画中的每个进程组称为一个工作job，会话可以有一个进程组成为会话的**前台**工作，而其他进程组是**后台**工作。每个会话可以连接一个控制终端，当控制终端有输入时，都传递给该会话的前台工作组。由终端产生的信号会传输到前台进程组。

会话的意义在于将多个工作囊括在一个终端中，并取其中一个工作为前台，来直接接收该终端的输入输出以及终端信号。其他工作在后台运行。

一个命令可以通过末尾加上`&`让他在后台运行。`ping localhost > log &`此时会显示`[1] 1111`，括号中的 1 表示工作号，而后面的数字表示 PGID。信号可以通过`kill`来发送，`kill -SIGTERM -1111`或`kill -SIGTERM %1`这样的方式发送给工作组，这两个命令是等价的，一个是发送给PGID一个是发送给工作1.

一个工作可以通过`fg`从后台工作变为前台工作：`fg %1`。

进程组（工作）的概念较为容易理解，而会话主要是针对一个终端来说的。当我们打开多个终端时实际上就创建了多个终端会话。每个终端会话都有自己的前台工作和后台工作。这样我们就为进程增加了管理和运行的层次，在没有图形化的时代，会话允许用户通过shell进行多层次的进程发起和管理。比如说我可以通过shell发起多个后台工作，而此时标准输入输出并不被占据，我依然可以继续其他的工作。如今图形化界面可以帮助我们解决这一需求但是工作组和会话机制仍然在Linux的很多地方使用。