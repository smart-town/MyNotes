# 映射

集是一个集合，它可以快速查找现有元素但是要查看元素需要有要查找元素的精确副本，这不是一种非常通用的查找方式。通常我们知道某些键的信息，并想要查找与之对应的元素。**映射** Map 就是为此设计的。映射用来存放键值对。如果提供了键就能够查找到值。

## 基本映射操作

Java 提供乐两个通用实现：`HashMap`和`TreeMap`。这两个类都实现了`Map`接口

散列映射对键进行散列，树映射用键的整体顺序对元素进行排序，并将其组织为搜索树，散列或比较函数**只能作用于键**，与键关联的值不能进行散列或者比较

与集一样，散列稍微快一些，如果不需要按照排列顺序访问键就最好选择散列。

- 添加对象：`map.put(key, value)`， 注意同一个键值不能存放两个值，事实上,put 将会返回这个键参数存储的上一个值
- 检索对象：`map.get(key)` 没有信息时返回`null`。返回`null`有时候可能很不方便，可以设置默认值：`map.getOrDefault(key,defaultValue)`
- 删除给定键对应元素：`map.remove(key)`
- `size()`返回映射中的元素数目

要迭代处理映射的键和值，最容易的方法是使用`forEach`方法，可以提供一个接收键和值的lambda表达式：
`map.forEach((k,v)->{System.out.println(k+","+v);})

## 更新映射项

处理映射时的一个难点就是更新映射项，正常情况下可以得到与一个键关联的原值，完成更新然后放回更新后的值。不过必须考虑一种特殊情况，即键第一次出现。如对于`counts.put(word,conuts.get(word)+1)`，该语句统计一个单词在文件中出现的频度，但是第一次看到`word`时，get 会返回`null`。可以这样处理：`counts.put(word,counts.getOrDefault(word,0)+1)`。

另外一种方式是首先调用`putIfAbsent`方法，只有当键原先存在时才会放入一个值
```java
counts.putIfAbsent(word,0);
counts.put(wortd,counts.get(word)+1);
```

不过还可以做的更好，使用`merge`方法可以简化这个常见操作：`counts.merge(word,1,Integer::sum)`将把`word`和1关联（如果键原先不存在），否则使用`Integer::sum`组合原值和1.

## 映射视图

集合框架不认为映射本身是一个集合，其他数据结构框架认为映射是一个键值对集合。不过，可以得到映射的视图view——实现了`Collection`接口或某个子接口的对象。

有三种视图：键集、值集合、键值对集。分别对应：`Set<K> keySet()`、`Collection<V> values()`、`Set<Map.Entry<K,V>> entrySet()`。

需要说明的是，`keySet`并不是`HashSet`或者`TreeSet`，而是实现了`Set`接口的另外某个类的对象。`Set`接口扩展了`Collection`接口，因此可以像使用集合一样使用`keySet`。

原先可以使用`entrySet`访问所有映射条目，现在可以用`forEach`就足够了。

如果在键集视图上调用迭代器的`remove`方法，实际上会从映射中删除这个键和它关联的值，不过不能像键集视图增加元素。

## 弱散列映射

设计`WeakHashMap`是为了解决一个有趣的问题，如果有一个值对应的键已经不再使用了，会出现什么情况呢？假定对某个键的最后一次引用已经消亡，不再有任何途径引用这个值的对象了，但是由于在程序的其他部分没有再出现这个键，所以这个键值对无法从映射中删除。为什么垃圾回收器不能够删除它呢？

垃圾回收器跟踪**活动的对象**，只要映射对象是活动的，那么其中所有的桶也都是活动的，它们不能被回收。因此需要由程序负责从长期存活的映射表中删除那些无用的值。或者使用`WeakHashMap`完成这件事情。当对键的唯一引用来自散列条目时，这一数据结构将与垃圾回收器协同工作一起删除键值对。

## 链接散列集和映射

`LinkedHashSet`和`LinkedHashMap`类用来记住插入元素项的顺序，这样就可以避免在散列表中的项看起来是随机排序的。当条目插入到表中时，就会并入到双向链表中。

**链接散列映射**将用**访问顺序**而不是插入顺序对映射条目进行迭代，每次调用`get`或`put`，受到影响的条目将从当前位置删除，并放到条目链表的尾部（只有条目在链表中的位置会受到影响，而散列表中的桶不会收到影响，一个条目总是位于与键散列码对应的桶中。）要构造这样一个散列映射表，需要调用`LinkedHashMap<K,V>(initialCapacity, loadFactor, true)`。

访问顺序对于实现高速缓存的“最近最少使用”原则十分重要。如，可能希望将访问频率高的元素放在内存中，而访问频率低的元素则从数据库中读取。当在表中找不到元素项且表已经满时，可以将迭代器加入到表中，并将枚举前几个元素删除掉，这些是近期最少使用的几个元素。

## 标识散列映射

类`IdentityHashMap`有特属的作用，在这个类中，键的散列值不是用`hashCode`函数计算的，而是用`System.indentityHashCode`方法计算的，这是`Object.hashCode`方法根据对象的内存地址来计算散列码时所用的方式。而且，在对两个对象进行比较时，`IdentityHashMap`类使用`==`而不是`equals`

也就是说，不同的键对象即使内容相同，也被视为是不同的对象，在实现对象遍历算法时，该类非常有用，可以用来跟踪每个对象的遍历状况。

## 枚举集与映射

`EnumSet`是一个枚举类型元素集的高效实现。由于枚举类型只有有限个实例，所以`EnumSetr`内部用位序列实现，如果对应的值在集中，则相应的位置被置为 1 。

`EnumSet`没有公共的构造器，可以使用静态工厂方法构造：
```java
enum Weekday { MONDAY, TUESDAY, WENDSEDAY } ;
EnumSet<Weekday> always = EnumSet.allOf(Weekday.class) ;
EnumSet<Weekday> never = Enum.noneOf(Weekday.class) ;
```

可以使用`Set`接口的常见方法来修改`EnumSet`

