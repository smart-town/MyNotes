# 生存还是死亡

即使在可达性分析中不可达的对象，也并非是“非死不可”的。这时候它们暂时处于“缓刑”状态。要真正宣告一个对象死亡，至少要经历过两次标记过程：如果对象在进行可达性分析之后，发现没有与 GC Roots 相连接的引用链，那么它将会被第一次标记并且进行一次筛选。筛选的条件是此对象是否有必要执行`finalize`方法。当对象么有覆盖`finalize()`或者虚拟机已经执行过该方法，虚拟机就会视为”没有必要执行“

如果这个对象被判定为有必要执行`finalize`方法，那么这个对象将会放置到一个`F-Queue`队列中，并在稍后由一个虚拟机自动建立的、低优先级的`Finalizer`线程去执行它。这里的执行是虚拟机会触发这个方法，但并不承诺等待它运行结束。这样做的原因是，如果一个对象在`finalize()`中执行缓慢或者发生了死循环，将很可能导致`F-Queue`队列中其他对象永久处于等待，甚至导致整个内存回收系统崩溃。`finalize()`方法是对象逃脱死亡命运的最后一次机会。稍后 GC 会对`F-Queue`中的对象进行第二次小规模的标记，如果对象要在`finalize()`中成功拯救自己——只要重新与引用链上任何一个对象建立关联即可，如将自己赋值给某个类变量，那么在第二次标记时它将被移除“即将回收”的集合；如果这个时候对象还没有逃脱，那么基本上它就真的被回收了。

需要特别声明的是，关于`finalize()`方法，建议尽量避免使用它。因为它不是 C/C++ 中的析构函数，而是 Java 刚刚诞生时为了 C/C++ 程序员更容易接受它所做的一个妥协。它的运行代价高昂，不确定性大，无法保证各个对象运行的顺序。`finalize()`所能做的工作，使用`try-finally`可以做的更好。