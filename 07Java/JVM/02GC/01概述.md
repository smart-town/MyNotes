# 垃圾收集器和内存分配策略

Garbage Collection,GC。事实上 GC 的历史比 Java 久远，Lisp 是第一门真正使用内存动态分配和垃圾收集技术的语言。当 Lisp 还在胚胎期时，人们就在思考 GC 需要完成的三件事情：
- 哪些内存需要回收
- 什么时候回收
- 如何回收
经过半个多世纪的发展，目前内存的动态分配与内存回收技术已经相当成熟，一切看起来都进入了“自动化”时代，那么为什么还要了解 GC？答案很简单，当需要排查各种内存溢出、内存泄露等问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，就需要对这些“自动化”技术实施必要的监控和调节。

Java运行时区域中，计数器、栈随着线程而生成或销毁，每一个栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈的操作。每个栈帧分配多少内存基本上是在类结构确定下来时就已知的。因此这几个区域的内存分配和回收都具有确定性。而 Java 堆和方法区不同，一个接口中的多个实现类可能需要的内存不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间时才知道会创建哪些对象，这部分内存的回收和分配都是动态的。垃圾收集器所关注的是这部分内存。

## 对象已死？

### 引用计数算法

很多判断对象是否存活的算法是这样的：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器就加1；当引用失效时，计数器就减1；任何时刻计数器为 0 的对象就不可能再被使用。

客观地说，Reference Counting 的实现简单，判定效率也很高。大部分情况下它是不错的算法，也有一些著名的应用案例，如微软公司的 COM、Python 等都使用了引用计数算法进行内存管理。但是，至少主流的 Java 虚拟机中没有选用引用计数算法管理内存，最主要的原因是它**很难解决对象之间相互循环引用的问题**

### 可达性分析算法

在主流的商用程序语言(Java、C#)的主流实现中，都是通过**可达性分析**(Reachability Analysis)来判断对象是否存活的。这个算法的思路就是通过一系列的称为“GC Roots”的对象作为起始点。从这些节点开始向下搜索，搜索所走过路径称为**引用链**，当一个对象到 GC Roots 没有任何引用链相连时，则证明这个对象是不可用的。

在 Java 中，可以作为 GC Roots 的对象包括：
- 虚拟机栈(栈帧中的本地变量表)中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈 JNI 引用的对象

## 再谈引用

无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象的引用链是否可达，判定对象是否存活都与“引用”有关。

JDK1.2 之后，Java 对引用的概念进行了扩充：强引用、软引用、弱引用、虚引用四种。这四种引用强度逐渐减弱。

强引用就是指在程序代码中普遍存在的，类似`Object o = new Object()`这类的引用。只要强引用还在，GC 永远不会回收掉被引用的对象。

软引用是用来描述一些还有用但并非必须的对象。对于软引用关联着的对象，在系统即将发生内存溢出之前，会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存异常溢出。jdk1.2 之后提供了`SoftReference`类来实现软引用。

弱引用也是用来描述非必需对象的。但是它的强度比软引用更弱一些。被弱引用对象关联的对象只能生存到下一次垃圾收集发生之前。在垃圾收集器工作时，无论当前内存是否足够，都会回收掉被弱引用关联的对象。提供了`WeakReference`类实现

虚引用也称为幽灵引用。它是最弱的一种引用。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响。也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。`PhantomReference`

