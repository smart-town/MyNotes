# 类加载器

虚拟机设计团队将类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到 JVM 外部实现，以便让应用程序能够自己决定如何去获取所需要的类，实现这个动作的代码模块称为类加载器。

类加载器可以说是 Java 语言的一项创新，也是 Java 语言流行的重要原因之一。

## 类与类加载器

类加载器虽然只用于实现类的加载动作，但是它在 Java 程序中起到的作用远远不限于类加载阶段，对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立起其在 JVM 中的唯一性。每一个类加载器，都拥有一个独立的类名称空间。

## 双亲委派模型

从 JVM 角度来讲，只存在两种不同类型的类加载器：一种是**启动类加载器**，这个类加载器使用C++语言实现，是虚拟机自身的一部分。另一种就是其他所有的类加载器，这些类加载器都由 Java 语言实现，独立于虚拟机外部，并且全部继承自`java.lang.ClassLoader`

从 Java 开发人员角度来讲，类加载器还可以分的更细一些，绝大多数 Java 程序都会用到以下 3 种系统提供的类加载器：

- **启动类加载器**,`Bootstrap ClassLoader`，该类加载器负责将`javahome\lib`中的，或被`-Xbootclasspath`所指定的路径中的，并且是虚拟机识别的(仅仅按照文件名识别，名字不符合的类库即使放在lib中也不会加载)类库加载到虚拟机内存中。启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要将加载请求委派给引导类加载器，直接使用`null`代替即可。
- **扩展类加载器**，负责加载`<java_home>\lib\ext`目录中的，或者被`java.ext.dirs`所指定的路径中的所有类库
- **应用程序类加载器**，由于该类是`ClassLoader`中的`getSystemClassLoader()`的返回值，所以一般也称为系统类加载器。负责加载用户类路径中所指定的类库。如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中的默认类加载器。

### 破坏双亲委派模型

双亲委派模型并不是一个强制性的约束模型，而是 Java 设计者推荐给开发者的类加载器实现方式。在 Java 中大部分的类加载器都遵循这个模型。但是也有例外，目前为止，双亲委派模型主要出现过三次较大规模的“被破坏”情况

第一次，即双亲委派模型出现之前。即 JDK1.2 发布之前。由于双亲委派模型 JDK1.2 之后才被引入，而类加载器和抽象类`java.lang.ClassLoader`则在 JDK1.0 时代就已经存在，面对已经存在的用户自定义类加载器的实现代码，Java 设计者不得不在引入双亲委派模型时作出一些妥协，为了向前兼容，JDK1.2 之后的 `java.lang.ClassLoader`添加了一个新的`protected`方法`findClass`，在此之前，用户去继承`java.lang.ClassLoader`的唯一目的就是为了重写`loadClass()`方法。因为虚拟机在进行类加载的时候会调用加载器的私有方法`loadClassInternal()`，而这个方法的唯一逻辑就是调用自己的`loadClass`。JDK1.2 之后已经不再提倡用户再去覆盖`loadClass()`方法，而应当将自己的逻辑写到`findClass()`方法中，`loadClass`的方法逻辑里如果在父类加载失败，则会调用自己的`findClass`方法来完成加载，这样就可以保证新写出来的类加载器是符合双亲委派规则的。

第二次，由这个模型自身的缺陷导致，双亲委派模型很好地解决了各个类加载器的基础类统一问题(越基础的类由越上层的类加载器加载)，但是如果基础类又要调用回用户的代码，怎么办呢？一个典型的例子就是`JNDI`，它的代码由启动类加载器加载，但是`JNDI`的目的就是对资源进行集中管理和查找，它需要调用独立厂商实现并部署在应用程序的`ClassPath`下的`JNDI`接口提供者（SPI）的代码，但是启动类加载器不可能认识这些代码呀。为了解决这个问题，只能引入一个不太好的设计：**线程上下文类加载器**，这个类加载器可以通过`java.lang.Thread`类的`setContextClassLoader`进行设置，如果创建线程时还未设置，则从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，默认为应用程序类加载器。  
有了线程上下文类加载器，就可以做一些“舞弊”的事情了，JNDI 服务使用这个线程上下文类加载器去加载所需要的 SPI 代码，也就是**父类加载器请求子类加载器去完成类加载动作**，这种行为实际上就打通了双亲委派模型的层次结构来逆向使用类加载器，但是这也无可奈何。Java 中所有涉及 SPI 的加载动作基本都采用这种方式。

第三次，是由于用户对程序动态性追求而导致的。即**代码热替换**、**模块热部署**等，说白了就是希望程序能够不用重启就能立即使用。如`OSGi`实现模块热部署的关键就是它自定义的类加载机制的实现，每一个程序模块(Bundle)都有一个自己的类加载器，当需要更换一个 Bundle 时，将 Bundle 连同类加载器一起换掉以实现代码的热替换。  
在 OSGI 环境下，类加载器不再是双亲委派中的树形结构，而是进一步发展为更复杂的网状结构。