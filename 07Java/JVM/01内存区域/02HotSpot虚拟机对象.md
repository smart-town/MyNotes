# HotSpot 虚拟机对象

知道虚拟机运行时数据区后，需要进一步了解其他细节，如它们是如何创建、布局、访问的。

## 对象的创建

在语言层面，创建对象仅仅是一个`new`关键字而已，而在虚拟机中，对象的创建（普通对象）又是如何进行的？虚拟机遇到一条`new`指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析、初始化过。如果没有则要执行相应的类加载过程。

类加载检查通过后，接下来虚拟机将为新生对象分配内存，对象所需要的内存大小在类加载完成后便可以完全确定。为对象分配空间的任务等同于将一块确定大小的内存从 Java 堆中划分出来。假设 Java 堆中内存是绝对规整的，所有用过的内存在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指向空闲指针那边挪动一段和对象大小相等的距离，这种分配方式称为“**指针碰撞**”(Bump the Pointer)。如果 Java 堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那么久没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例并更新列表记录，这种分配方式称为“**空闲列表**”(Free List)。

选择哪种分配方式由 Java 堆是否规整决定，而规整则取决于采用的垃圾收集器是否带有压缩整理功能决定。因此使用 Serial 等带 Compact 过程的收集器时系统采用的分配方式是指针碰撞。

除了划分可用空间外，还有另一个需要考虑的是，对象创建在虚拟机中是非常频繁的行为，即使是仅仅修改一个指针指向的位置，在并发情况下也不是线程安全的。可能出现正在给对象 A 分配内存，指针还没来得及修改，对象 B 又同时使用了原来的指针来分配内存的情况。解决该问题有两个方案：一种是对分配内存空间的操作进行同步处理；一种是将内存分配的动作按照线程划分到不同的空间之中进行，即每个线程在 java 堆中预先分配一个小内存，称为**本地线程分配缓冲**(Thread Local Allocation Buffer,TLAB)。哪个线程需要分配内存就在哪个线程的`TLAB`上分配，只有`TLAB`使用完并分配新的`TLAB`时才需要同步锁定。可以通过`-XX:+/-UseTLAB`来设定是否启用。

内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值。如果使用 TLAB 这一过程可以提前到 TLAB 分配时进行。这一步操作确保了对象的实例字段在 Java 代码中可以不用赋予初始值就可以使用。

接下来，虚拟机要对对象进行必要的设置。例如这个对象是哪个类的实例，如何才能找到类的元数据信息、对象的哈希码、GC 分代年龄等信息。这些信息放在对象的对象头(Object Header)中，根据虚拟机当前的运行状态不同，如是否启用偏向锁等，对象头会有不同的设置方式。

上面工作都完成后，从虚拟机的角度来看，一个新的对象已经产生了。但是从 Java 程序角度来看，对象的创建才刚刚开始。`init`方法还没有执行，所有的字段都还为0.所以一般来说，执行`new`指令后，会接着执行`init`方法，将对象按照程序员的意愿初始化。这样一个真正的可用对象才算完全生产出来。

