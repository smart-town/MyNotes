# 对象内存布局和访问

## 内存布局

在 HotSpot 虚拟机中，对象在内存中存储的布局可以分为 3 块区域：对象头、实例数据、对齐填充

对象头包括两部分信息：第一部分存储对象自身的运行数据如哈希码、GC分代年龄、锁状态标识、线程持有的锁、偏向线程ID、偏向时间戳等。这部分数据长度在 32 位和 64 位虚拟机（未开启指针压缩）中分别为 32bit和64bit，官方称为“Mark Word"。对象需要存储的运行时数据很多，其实已经超过了 32、64bit。但是对象头信息是与对象自身定义的数据无关的额外存储成本。考虑到虚拟机空间效率，Mark Word 被设计为一个非固定的数据结构以便在极小的空间内存储尽量多的信息。它会根据对象状态复用自己的存储空间。

对象头的另一部分是类型指针，即对象指向它的类元数据的指针。虚拟机通过这个指针来确定这个对象是哪个类的实例，并不是所有的虚拟机实现都必须在对象数据上保留类型指针。另外如果对象是一个 Java 数组，那么在对象头中还有一块用于存储数组长度的数据。

接下来的**实例数据**部分，是对象真正存储的有效信息。也是在程序码中所定义的各种类型的字段内容。无论是从父类继承下来的还是在子类中定义的，都需要记录起来。这部分的存储顺序会受到虚拟机分配策略参数和字段在源码中定义顺序的影响。HotSpot 默认分配策略为：`longs/doubles`、`ints`等。

第三部分**对齐填充**并不是必然存在的，也没有特别的含义。它仅仅起着占位符的作用。由于 HotSpot VM 的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍。即对象大小必须是 8 字节的整数倍。而对象头部分正好是 8 字节的倍数，1或2倍。因此当对象实例数据没有对齐时就要通过对齐填充来补全。

## 对象访问定位

建立对象是为了使用对象，Java 程序需要通过栈上的`reference`数据来操作堆上的具体对象。由于`reference`类型在 JVM 规范中只规定了一个指向对象的引用，并没有定义这个引用应该通过何种方式去定位、访问堆中的对象的具体位置，所以对象访问方式也是取决于虚拟机实现而定的。目前主流的方式有**使用句柄**和**直接指针**两种。

如果使用句柄访问的话，那么 Java 堆中将会划分出一块内存作为句柄池。`reference`中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。

如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息。而`reference`中存储的直接就是对象地址。

这两种对象访问方式各有优势。使用句柄来访问的最大好处就是`reference`中存储的是稳定的句柄地址，在对象被移动时（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而`reference`本身不用修改

而使用直接指针的最大好处在于，它节省了一次指针定位的时间开销，由于对象的访问在 java 中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。对于 HotSpot 而言，它是使用第二种方式进行对象访问的。