# Object:所有类的超类

Object 类是 Java 中所有类的始祖。爱 Java 中每个类都是由它扩展来的。

Object 类型变量可以引用任何类型的对象。当然，Object 类型变量只能用于作为各种值的通用持有者，要想对其中的内容进行具体的操作，还需要清楚对象的原始类型并进行相应的类型转换。

在 Java 中，只有**基本类型**不是对象。所有的数组类型，不管是对象数组还是基本类型数组都扩展了 Object 类。

## equals 方法

Object 类中 equals 方法检测一个对象是否等于另外一个对象。Object 中默认是判断两个对象是否引用的同一个对象。

但是实际情况下，通常认为两个对象的状态相同就是相等。

通常可以使用`Objects.equals(a,b)`判断相等，因为 a 或 b 有可能为空。

通常子类中定义`equals`方法中时，可以先调用超类的 `equals`，因为如果超类检测失败，对象就不可能相等。

【注意】隐式参数和显式参数不属于同一个类的情况。很有争议的一个问题。`A.equals(B);` 假设 B 继承自 A。比较时可能将 B 转换为 A，从而比较状态，判断。但是反过来`B.equals(A)`则会出现问题，因为 A 是超类，而 B 是子类。强制转换后很容易出现问题。

通常可以判断`this.getClass() == obj.getClass()`

## hashCode 方法

**散列码**是由对象导出的一个整型值。散列码是没有规律的。

对于`Object`而言，默认 hashCode 为对象的存储地址。而对于 String 类型而言，有其自定义的计算方法。

如果重新定义`equals`方法，那么就**必须**重新定义 hashCode 方法，以便用户可以将对象插入到**散列表**中。通常 hashCode 方法应该返回一个整型数值，并合理组合实例域的散列码。

常用的一个组合实例域做法：`return Objects.hash(name, harry, hireDay)`

## toString 方法

用于返回表示对象值的字符串。通常遵循的格式为类名+域值

随处可见 toString 方法的主要原因是，只要对象与一个字符串通过操作符"+"连接起来，Java 编译就会自动调用 toString 方法以便获得这个对象的字符串描述。

`Object`类的`toString`方法输出对象**类名**和**散列码**

【注意】数组继承了 object 类的 toString 方法。

要打印数组则需要调用`Arrays.toString(array)`

## clone 方法

**浅拷贝**和**深拷贝**

对于每一个类，需要确定：
- 默认的 clone 方法是否满足需求
- 是否可以在可变的子对象上调用 clone 来修补默认的 clone 方法
- 是否不该使用 clone 

如果确定要使用`clone`，那么类必须 实现`Clonable`接口，重新定义`clone`方法并指定`public`修饰符。

这里`Clonable`接口的出现与接口的正常使用并没有关系，具体来说，他没有指定`clone`方法，这个方法是从`Object`继承而来的。该接口**只是作为一个标记**，指示类设计者了解克隆过程。