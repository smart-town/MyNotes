# 多线程基本使用

## 1.创建

1. 实现`Runnable`接口的`run`方法（函数式接口，可以使用 lambda）
2. 由`Runnable`创建一个`Thread`对象
3. 启动线程`start()`

另外，也可以通过继承`Thread`来构建子类，并启动`start`，不过现在已经并不推荐。**应该将要并行运行的任务和运行机制解耦**。如果有很多的任务的话，要为每个任务创建一个独立的线程付出的代价太大了，可以使用线程池来解决这个问题。

【注意】不要调用`Thread`或`Runnable`中的`run()`，这样只会执行同一个线程中的任务，而不会启动新线程。应该调用`start()`

## 2.中断线程

**没有可以强制线程终止的方法**，`interrupt`可以用来请求终止线程。

对一个线程调用`interrupt`方法，线程的**中断状态**将会被置位。这是每一个线程都具有的`boolean`标志，每个线程都应该不时地检查这个标志，以判断线程是否被置位。判断是否被置位：`isInterrupted()`。如`Thread.currentThread().isInterrupted()`

但是，如果线程被阻塞，就无法检测终端中泰，这是产生`InterruptedException`异常的地方。

没有任何语言方面的需求要求一个被中断的线程应该终止。中断一个线程不过是引起它的注意。被中断的线程可以决定如何响应终端，某些线程是如此重要以至于应该处理完异常后继续执行，而不理会中断。但是更普遍的情况是，线程简单地将中断作为一个终止的请求：
```java
Runnable r = ()->{
    try {
        ...
        while(!Thread.currentThread().isInterrupted() &&..){
            do work.
        }
    } catch(InterruptedException e){
        ...
    } finally {
        ...
    }
}
```

## 线程状态

- New 新创建
- Runnable 可运行
- Blocked 被阻塞
- Waiting 等待
- Thimed waiting 计时等待
- Terminated 被终止

### 新建和可运行

使用`new`操作符创建一个新线程时，就意味着它的状态是`new`。当一旦调用`start`方法时，线程处于`Runnable`状态。一个可运行的线程可能正在运行也可能是没有运行。这取决于操作系统给线程提供的运行时间。线程调度的细节依赖于操作系统提供的服务。**抢占式**调度系统给每一个可运行的线程一个时间片执行任务。当时间片用完操作系统剥夺该线程的运行权，并给另外一个线程运行机会。当选择下一个线程时，操作系统考虑线程的优先级。

现在所有的桌面以及服务器操作系统都使用抢占式调度，但是像手机这样的小型设备可能使用**协作式**调度。

在具有多个处理器的机器上，每一个处理器运行一个线程，可以有多个线程并行运行。当然如果线程数目多于处理器的数目，那么调度器依然采用时间片机制。

### 被阻塞和等待

当线程处于被阻塞或者等待状态时，它暂时不活动。它不运行代码且消耗最少的资源。直到线程调度器重新激活它。细节取决于它是如何到达非活动状态的：
- 线程试图获取一个内部的对象锁而该锁被其他线程持有，则线程进入**阻塞**状态。当所有其他线程释放该锁，并且线程调度器允许本线程持有它时，该线程才变成非阻塞状态
- 线程等待另一个线程通知调度器一个条件时，它自己进入**等待**状态。调用`Object.wait`或`Thread.join`，或者`Lock`、`Condition`时就会出现这种情况。
- 有几个方法有一个超时参数，调用它们导致线程进入**计时等待**。这一状态保持到超时期满或者接收到适当通知

### 线程终止

- run 方法正常退出
- 因为没有捕获异常终止了 run 方法而意外死亡

注意虽然可以调用`stop`方法终止一个线程，但是该方法已经过时，不要调用。

## 线程属性

线程优先级、守护线程、线程组、处理未捕获异常的处理器

### 线程优先级

Java 中每一个线程有一个**优先级**，正常情况下，一个线程**继承***它的父线程的优先级。可以用`setPriority`方法提高或降低任何一个线程的优先级。可以将优先级设置为`MIN_PRIORITY`到`MAX_PRIORITY`（1~10）之间的任何值。

每当线程调度器有机会选择新线程时，它首先选择具有较高优先级的线程。但是，线程的优先级是**高度依赖于系统**的，当虚拟机依赖于宿主平台的线程实现机制时，Java 线程的优先级被映射到宿主平台的优先级上，优先级个数可能更多也可能是更少。

如，Windows 中有 7 个优先级别，一些Java 优先级将会映射到相同的操作系统优先级。在 Oracle 为 Linux 提供的虚拟机中，线程的优先级被忽略，即**所有的线程具有相同的优先级**

【注意】如果有几个高优先级的线程没有进入非活动状态，那么低优先级的线程可能永远也无法执行。每当调度器决定运行一个新线程时，首先会在具有高优先级的线程中进行选择。尽管这样会使得低优先级的线程完全饿死。

### 守护线程

可以通过调用`t.setDaemon(true)`将一个线程转换为**守护线程**(daemon thread)。守护线程的唯一用途是**为其他线程提供服务**。计时线程就是一个例子。它定时地发送计时信号给其他线程。当只剩下守护线程时，虚拟机就退出了，由于如果只剩下守护线程，就没有必要继续运行程序了。

守护线程应该永远不去访问固有资源，如文件、数据库。因为他会在任何时候甚至一个操作的中间发生终端。

### 未捕获异常处理器

线程的 `run` 方法不能抛出任何受查异常，但是非受查异常会导致线程终止，这种情况下，线程早就死亡了。

但是不需要任何`catch`子句来处理可以被传播的异常，相反，就在线程死亡之前，异常被传递到一个用于未捕获异常的处理器。

该处理器必须属于一个实现了`Thread.UncaughtExceptionHandler`接口的类。这个接口只有一个方法：`void uncaughtException(Thread t, Throwable e)`。可以用`setUncaughtExceptionHandler`为任何线程安装一个处理器。也可以用`Thread`的静态方法`setDefaultUncaughtExceptionHandler`为所有线程安装一个默认处理器。替换处理器可以使用日志 API 发送未捕获异常的报告到日志文件中。

如果不安装默认的处理器，默认为空。但是如果不为独立的线程安装处理器，此时的处理器就是该线程的`ThreadGroup`对象。

**线程组**是一个可以统一管理的线程集合。默认情况下，创建的所有线程属于相同的线程组。但是也可能会建立其他的线程组，现在引入了更好的特性用于线程集合的操作。所以建议不要在自己的程序中使用线程组。

`ThreadGroup`类实现了`Thread.UncaughtExceptionHandler`接口，